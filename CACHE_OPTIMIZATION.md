# Azure TTS 缓存优化说明

## 🎯 优化目标

解决用户反复点击播放按钮时重复调用 Azure TTS API 的问题，通过智能缓存机制减少 API 消耗。

## ✨ 功能特性

### 1. 智能缓存机制
- **缓存键生成**：基于文本内容、口音、性别生成唯一缓存键（语速通过本地播放控制）
- **自动缓存管理**：最多缓存 50 个音频文件，采用 FIFO（先进先出）策略
- **内存管理**：自动释放过期的 Blob URL，防止内存泄漏
- **语速控制**：通过 HTML5 Audio 的 playbackRate 属性本地调节，无需重新调用 API

### 2. 缓存生命周期
- **页面刷新**：自动清除所有缓存
- **内容更换**：切换到新文本时自动清除缓存
- **组件卸载**：组件销毁时清理所有缓存资源

### 3. API 调用优化
- **首次播放**：调用 Azure TTS API 并缓存结果
- **重复播放**：直接使用缓存，无需重复调用 API
- **语速变化**：通过本地 playbackRate 调节，不重新调用 API
- **不同参数**：不同的口音、性别组合会生成新的缓存项

## 🧪 测试方法

### 开发环境测试

在浏览器控制台中使用以下命令：

```javascript
// 查看当前缓存状态
checkTTSCache()

// 手动清除缓存
azureTtsService.clearCache()

// 获取详细缓存信息
azureTtsService.getCacheStats()
```

### 功能验证步骤

1. **输入测试文本**：在应用中输入一段英文文本
2. **首次播放**：点击播放按钮，观察控制台输出 "调用Azure TTS API"
3. **重复播放**：再次点击播放，观察控制台输出 "使用缓存的音频"
4. **参数变化**：切换语速或口音，验证会重新调用 API
5. **缓存清理**：刷新页面或输入新文本，验证缓存被清除

## 📊 性能提升

### API 调用减少
- **场景1**：重复播放同一内容 → 节省 100% API 调用
- **场景2**：全篇朗读后分段朗读 → 复用已缓存的分段内容
- **场景3**：切换播放速度 → 本地调节，完全无需调用 API
- **场景4**：快速/慢速切换 → 即时响应，无网络延迟

### 用户体验改善
- **响应速度**：缓存播放几乎无延迟
- **网络依赖**：减少对网络连接的依赖
- **成本控制**：显著降低 Azure TTS API 使用费用

## 🔧 技术实现

### 缓存键格式
```
{文本内容}-{口音}-{性别}
例如："Hello world-us-male"
```

### 缓存数据结构
```javascript
{
  blob: AudioBlob,      // 音频二进制数据
  url: ObjectURL,       // 音频播放URL
  timestamp: Number     // 缓存时间戳
}
```

### 内存管理
- 缓存上限：50 个音频文件
- 清理策略：FIFO（先进先出）
- URL 管理：自动释放 Blob URL 防止内存泄漏

## 🚀 使用建议

1. **合理使用**：避免在短时间内大量切换不同参数
2. **监控缓存**：在开发环境中定期检查缓存状态
3. **测试验证**：部署前验证缓存功能正常工作
4. **性能监控**：关注 API 调用次数的减少情况

## 📝 注意事项

- 缓存仅在当前会话有效，页面刷新后重置
- 不同的文本内容会生成独立的缓存项
- 缓存大小限制防止内存过度使用
- 开发环境提供调试工具，生产环境自动隐藏