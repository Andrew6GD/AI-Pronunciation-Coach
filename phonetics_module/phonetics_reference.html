<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÁªÉ‰π† - AI Pronunciation Coach</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Doulos+SIL&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #f8fafc;
            --card: #ffffff;
            --text: #1e293b;
            --muted: #64748b;
            --primary: #6366f1;
            --primary-weak: #eef2ff;
            --accent: #22c55e;
            --danger: #ef4444;
            --border: #e2e8f0;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --shadow-lg: 0 8px 25px rgba(0, 0, 0, 0.12);
            --radius: 16px;
            --radius-sm: 8px;
            --font-body: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-ipa: 'Doulos SIL', 'Charis SIL', 'Gentium Plus', 'Noto Serif', 'Times New Roman', 'Georgia', serif;
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background: var(--bg);
            color: var(--text);
            font-family: var(--font-body);
            font-size: 16px;
            line-height: 1.5;
            /* Á¶ÅÁî®Â§ñÂ±ÇÊªöÂä®Ôºå‰ªÖÂú®ÂÜÖÂÆπÂå∫ÊªöÂä® */
            overflow: hidden;
        }

        .page {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
        }

        /* Enhanced Topbar */
        .topbar {
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: saturate(1.2) blur(12px);
            background: rgba(255, 255, 255, 0.95);
            border-bottom: 1px solid var(--border);
            height: 72px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            padding: 0 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }

        /* Enhanced Bottom Bar */
        .bottombar {
            position: sticky;
            bottom: 0;
            z-index: 100;
            backdrop-filter: saturate(1.2) blur(12px);
            background: rgba(255, 255, 255, 0.95);
            border-top: 1px solid var(--border);
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            padding: 0 20px;
            box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.04);
        }

        .content {
            position: relative;
            flex: 1;
            overflow: auto;
            padding: 32px 20px 140px;
            /* Ëá™ÂÆö‰πâÊªöÂä®Êù°ÔºöÈªòËÆ§ÈöêËóèÔºåhover/ÊªöÂä®Êó∂ÊòæÁ§∫ÔºåÊõ¥ÊµÖÈ¢úËâ≤ */
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: transparent transparent; /* Firefox ÈªòËÆ§ÈöêËóè */
        }
        .content:hover { scrollbar-color: rgba(60,60,60,0.25) transparent; }
        /* WebKit ÊªöÂä®Êù°Ê†∑Âºè */
        .content::-webkit-scrollbar {
            width: 10px;
            background: transparent;
        }
        .content::-webkit-scrollbar-thumb {
            background-color: rgba(60,60,60,0.18); /* Êõ¥ÊµÖ */
            border-radius: 8px;
            border: 3px solid transparent; /* ÂΩ¢ÊàêÂÜÖÂáπÊïàÊûúÔºåËøõ‰∏ÄÊ≠•ÂèòÊµÖ */
            background-clip: padding-box;
            opacity: 0; /* ÂàùÂßãÈöêËóèÔºàÁªìÂêà‰∏ãÈù¢ÈÄâÊã©Âô®ÊéßÂà∂ÂèØËßÅÔºâ */
        }
        .content::-webkit-scrollbar-track {
            background: transparent;
        }
        /* ÈªòËÆ§Â∞ΩÈáèÈöêËóèÔºåÈº†Ê†áÊÇ¨ÂÅúÂà∞ÂÜÖÂÆπÂå∫ÊàñÊ≠£Âú®ÊªöÂä®Êó∂ÂÜçÂèØËßÅ */
        .content:hover::-webkit-scrollbar-thumb,
        .content:active::-webkit-scrollbar-thumb {
            opacity: 1;
            background-color: rgba(60,60,60,0.28);
        }

        /* Enhanced Floating Logo */
        .floating-logo {
            position: fixed;
            left: 20px;
            top: 10px;
            z-index: 200;
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
            cursor: pointer;
            user-select: none;
            background: var(--card);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            border-radius: 999px;
            padding: 12px 16px;
            gap: 10px;
        }

        .floating-logo.compact {
            padding: 12px;
        }

        .floating-logo .logo {
            width: 28px;
            height: 28px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            background: transparent;
            padding: 0;
        }
        .floating-logo .logo svg { width: 28px; height: auto; display: block; }
        .floating-logo .text {
            white-space: nowrap;
            font-weight: 600;
            letter-spacing: 0.3px;
            font-size: 15px;
        }

        /* Enhanced Buttons */
        .btn {
            height: 42px;
            padding: 0 16px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--card);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            color: var(--text);
        }

        .btn:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.08);
            transform: translateY(-1px);
        }

        .btn.primary {
            background: var(--primary);
            color: white;
            border-color: transparent;
        }

        .btn.ghost {
            background: transparent;
            border-color: transparent;
        }

        .btn.toggled {
            border-color: var(--primary);
            background: var(--primary-weak);
            color: var(--primary);
        }
        /* Eye icon + label layout */
        .btn .icon { display: inline-flex; align-items: center; line-height: 0; }
        .btn .icon svg { width: 18px; height: 18px; display: block; }
        .btn .label { line-height: 1; }

        /* Disabled button state */
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Enhanced Segmented Control */
        .seg {
            display: inline-flex;
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            background: var(--card);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
        }

        .seg .item {
            padding: 10px 18px;
            cursor: pointer;
            border-right: 1px solid var(--border);
            transition: all 0.2s ease;
            font-size: 14px;
            font-weight: 500;
            position: relative;
        }

        .seg .item:last-child {
            border-right: none;
        }

        .seg .item.active {
            background: var(--primary);
            color: white;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .seg .item:not(.active):hover {
            background: #f8fafc;
        }

        /* Enhanced Speed Control */
        .speed {
            display: inline-flex;
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            background: var(--card);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
        }

        .speed .sitem {
            padding: 10px 16px;
            cursor: pointer;
            border-right: 1px solid var(--border);
            transition: all 0.2s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .speed .sitem:last-child {
            border-right: none;
        }

        .speed .sitem.active {
            background: var(--primary);
            color: white;
        }

        .speed .sitem:not(.active):hover {
            background: #f8fafc;
        }

        /* Enhanced Sentence Cards */
        .sentence-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 24px;
            margin: 24px auto;
            max-width: 960px;
            transition: all 0.2s ease;
        }

        .sentence-card:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }

        /* Enhanced Tokens */
        .tokens {
            display: flex;
            flex-wrap: wrap;
            gap: 20px 20px;
            font-size: 24px;
            line-height: 1.4;
        }

        .token {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .token .word {
            padding: 8px 12px;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .token:hover .word {
            background: #f1f5f9;
            transform: translateY(-1px);
        }

        /* Active word highlight during recording */
        .token.active .word {
            color: #1d4ed8;
            background: #dbeafe;
            box-shadow: 0 4px 12px rgba(29, 78, 216, 0.12);
        }
        /* Fade-out animation when clearing blue highlight */
        @keyframes blueFadeOut {
            0% { color:#1d4ed8; background:#dbeafe; box-shadow: 0 4px 12px rgba(29, 78, 216, 0.12); }
            100% { color: inherit; background: transparent; box-shadow: none; }
        }
        .token.fadeout .word { animation: blueFadeOut 0.6s ease forwards; }

        /* Particles rising effect */
        .particle { display: none !important; }
        .particle.square { display: none !important; }
        .particle.triangle { display: none !important; }
        .particle { border-radius: 2px; background: #93c5fd; }
        .particle.triangle {
            width: 0; height: 0; background: transparent; border-left: 5px solid transparent; border-right: 5px solid transparent; border-bottom: 9px solid #3b82f6;
        }

        @keyframes rise {
            from { transform: translateY(0) scale(1); opacity: 0.95; }
            to { transform: translateY(-48px) scale(0.8); opacity: 0; }
        }
        @keyframes wobble {
            0% { transform: translateX(0); }
            50% { transform: translateX(-6px); }
            100% { transform: translateX(6px); }
        }

        /* Enhanced IPA Styling */
        .token .ipa {
            font-family: var(--font-ipa);
            font-size: 14px;
            line-height: 1.4;
            color: var(--muted);
            text-align: center;
            letter-spacing: 0.5px;
            transition: all 0.2s ease;
            margin-top: 0;
        }

        /* Focus states for accessibility */
        .btn:focus-visible, .seg .item:focus-visible, .speed .sitem:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        .seg .item:not(.active):hover {
            background: #f8fafc;
        }

        /* Enhanced Speed Control */
        .speed {
            display: inline-flex;
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            background: var(--card);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
        }

        .speed .sitem {
            padding: 10px 16px;
            cursor: pointer;
            border-right: 1px solid var(--border);
            transition: all 0.2s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .speed .sitem:last-child {
            border-right: none;
        }

        .speed .sitem.active {
            background: var(--primary);
            color: white;
        }

        .speed .sitem:not(.active):hover {
            background: #f8fafc;
        }

        /* Progress Bar */
        .progress-container {
            margin: 20px auto;
            max-width: 1000px;
            background: #f1f5f9;
            border-radius: 8px;
            height: 8px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            border-radius: 8px;
            transition: width 0.3s ease;
            width: 0%;
        }

        /* Dictionary Controls */
        .dict-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .dict-file-input {
            display: none;
        }

        /* Recording Visualization removed */
        .recording-viz {
            display: none;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 8px;
            margin: 16px 0;
        }

        .recording-viz.active {
            display: flex;
        }

        .waveform {
            flex: 1;
            height: 40px;
            background: #fee2e2;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .waveform-bar {
            position: absolute;
            bottom: 0;
            width: 2px;
            background: var(--danger);
            border-radius: 1px;
            animation: waveAnimation 0.5s ease-in-out infinite alternate;
        }

        @keyframes waveAnimation {
            from { height: 20%; }
            to { height: 80%; }
        }

        .spacer {
            flex: 1;
        }

        .play {
            min-width: 100px;
        }

        .record {
            min-width: 130px;
        }

        .record.recording {
            background: var(--danger);
            color: white;
            border-color: transparent;
        }

        /* Keyboard Navigation Hint */
        .keyboard-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .keyboard-hint.show {
            opacity: 1;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .topbar {
                height: 68px;
                padding: 0 16px;
                flex-wrap: wrap;
                gap: 12px;
            }

            .bottombar {
                height: 84px;
                padding: 0 16px;
                flex-wrap: wrap;
                gap: 12px;
            }

            .content {
                padding: 20px 16px 160px;
            }

            .tokens {
                font-size: 20px;
                gap: 16px;
            }

            .sentence-card {
                padding: 20px;
                margin: 16px;
            }
        }

        @media (max-width: 640px) {
            .tokens {
                font-size: 18px;
                gap: 14px;
            }

            .seg .item,
            .speed .sitem {
                padding: 8px 12px;
                font-size: 13px;
            }
        }

        /* ========= Score Card (new) ========= */
        .score-card { display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .score-summary { text-align: center; padding: 8px 0 4px; }
        .score-number { font-size: 64px; font-weight: 800; line-height: 1; margin: 8px 0; }
        .stars { display: flex; gap: 8px; justify-content: center; align-items: center; margin: 6px 0 8px; }
        .star { width: 28px; height: 28px; color: #e5e7eb; }
         .star.on { color: #f59e0b; }
         /* Star size pattern: small ‚Üí medium ‚Üí large ‚Üí medium ‚Üí small (scaled up) */
         .stars .star:nth-child(1),
         .stars .star:nth-child(5) { width: 20px; height: 20px; }
         .stars .star:nth-child(2),
         .stars .star:nth-child(4) { width: 26px; height: 26px; }
         .stars .star:nth-child(3) { width: 36px; height: 36px; }
        .score-phrase { font-size: 20px; font-weight: 800; font-style: italic; color: var(--muted); letter-spacing: 0.6px; margin-top: 6px; }
        .score-details { color: var(--muted); white-space: pre-wrap; margin-top: 8px; display:none; }
        /* ÈöêËóèËØÑÂàÜÊ®°ÂºèÂàáÊç¢ÊåâÈíÆ */
        #scoreModeSwitch { display:none; }
        /* ÊèêÁ§∫Â∞èÂ≠óÊ†∑Âºè */
        .score-note { font-size: 12px; color: rgba(34, 197, 94, 0.65); margin-top: 16px; }
        /* FAC breakdown styles */
        .fac-breakdown{ display:flex; justify-content:center; gap:28px; margin-top:10px; flex-wrap:wrap; }
        .fac-item{ text-align:center; min-width:84px; }
        .fac-item .fac-label{ font-size:13px; color:var(--muted); }
        .fac-item .fac-score{ font-size:22px; font-weight:800; margin-top:2px; }
        .fac-item .fac-sub{ font-size:12px; color:var(--muted); letter-spacing:.3px; }
        /* Phoneme chips + timeline + mode switch */
        .chips{ display:flex; flex-wrap:wrap; gap:8px; justify-content:center; margin-top:8px; }
        .chip{ padding:4px 10px; border-radius:999px; font-size:12px; border:1px solid #e5e7eb; background:#f3f4f6; color:#111827; }
        .chip.warn{ background:#fff7ed; border-color:#fed7aa; color:#9a3412; }
        .chip.bad{ background:#fee2e2; border-color:#fecaca; color:#991b1b; }
        .timeline{ height:10px; border-radius:6px; overflow:hidden; background:#e5e7eb; max-width:560px; width:100%; margin:10px auto 0; position:relative; }
        .timeline .seg{ height:100%; display:inline-block; }
        .timeline .seg.ok{ background:#22c55e; }
        .timeline .seg.warn{ background:#f59e0b; }
        .timeline .seg.bad{ background:#ef4444; }
        .mode-switch{ display:flex; gap:8px; justify-content:center; margin-top:6px; }
        .mode-switch .ms-btn{ font-size:12px; padding:4px 10px; border:1px solid #e5e7eb; border-radius:999px; background:#fff; color:#374151; cursor:pointer; }
        .mode-switch .ms-btn.active{ background:#111827; color:#fff; border-color:#111827; }
        /* Accent dropdown menu */
        .dropdown{ position:absolute; background:#fff; border:1px solid #e5e7eb; border-radius:10px; box-shadow:0 8px 24px rgba(0,0,0,.08); padding:6px; display:none; z-index:1000; }
        .dropdown .dd-item{ padding:6px 10px; border-radius:8px; cursor:pointer; font-size:14px; white-space:nowrap; }
        .dropdown .dd-item:hover{ background:#f3f4f6; }
    </style>
</head>
<body>
    <!-- Enhanced Floating Logo -->
    <div class="floating-logo compact" id="floatingLogo">
        <div class="logo"><svg width="810" height="744" viewBox="0 0 810 744" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_5_14)"><path d="M588.5 0C710.831 0.000124107 810 99.169 810 221.5C810 327.092 736.114 415.425 637.222 437.623C583.067 453.483 503.271 444.697 372.686 444.697C352.186 445.697 334.735 463.636 294.686 534.697C189.934 720.56 126.715 742.284 106.926 743.965C102.924 744.305 100.19 740.928 100.196 736.911L100.946 281.821C100.951 279.427 102.662 277.403 104.963 276.74C121.767 271.901 137.208 256.357 131.186 214.197C123.002 156.913 103.186 98.6975 48.1857 85.1973C43.1859 83.3322 82.186 0.197266 200.686 0.197266H576.686C578.895 0.100941 581.178 0.0531582 583.528 0.0556641C585.181 0.019267 586.839 0 588.5 0ZM352.5 65C344.5 45.5 227.186 26.1967 185.186 72.6963C116.56 148.674 181.056 204.876 235.057 222.882C242.227 225.273 245.418 234.295 240.944 240.388C214.964 275.766 179.719 339.124 194.186 406.197C206.768 464.531 222.281 482.302 235.526 491.935C239.418 494.765 244.854 493.589 247.607 489.643L425.333 234.87C428.64 230.13 429.133 223.975 426.623 218.769L352.5 65ZM695.186 217.197C695.186 84.8936 545.541 104.121 433.857 104.494C432.38 104.499 431.436 106.045 432.081 107.373L447.557 139.252C449.521 143.299 453.3 146.164 457.747 146.845C480.953 150.395 521.795 154.848 549.686 156.197C574.191 157.383 592.106 157.87 600.173 158.391C602.186 158.521 603.695 160.202 603.409 162.198C600.358 183.5 571.588 224.567 490.75 233.472C488.708 233.697 488.356 236.133 490.343 236.657C511.695 242.293 553.573 242.744 567.813 242.727C570.341 242.723 572.142 244.976 571.191 247.318C565.826 260.524 542.728 297.467 452.251 297.226C450.089 297.22 448.011 298.332 446.818 300.136C441.711 307.859 429.518 324.958 424.452 332.035C423.504 333.36 424.457 335.197 426.086 335.197H546.686C609.186 335.197 695.185 322.697 695.186 217.197Z" fill="#34C369"/><path d="M92.1857 175.697C81.3857 131.697 51.1857 113.697 35.6859 115.197C18.6857 116.842 4.80484 165.744 0.685708 198.697C-6.31427 254.697 42.5244 338.197 45.1857 305.197C47.6857 274.197 50.6857 267.697 56.6857 260.697C66.0716 249.747 89.686 258.197 96.686 251.197C103.686 244.197 105.686 230.697 92.1857 175.697Z" fill="#3F3F3F"/><path d="M240.686 84.6968C266.643 84.6968 287.686 105.739 287.686 131.697C287.686 157.654 266.643 178.697 240.686 178.697C214.728 178.697 193.686 157.654 193.686 131.697C193.686 105.739 214.728 84.6968 240.686 84.6968ZM240.686 109.697C228.536 109.697 218.686 119.547 218.686 131.697C218.686 143.847 228.536 153.697 240.686 153.697C252.836 153.697 262.686 143.847 262.686 131.697C262.686 119.547 252.836 109.697 240.686 109.697Z" fill="#323230"/></g><defs><clipPath id="clip0_5_14"><rect width="810" height="744" fill="white"/></clipPath></defs></svg></div>
        <div class="text">AI Pronunciation Coach</div>
    </div>

    <!-- Progress Bar -->
    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>

    <!-- Keyboard Navigation Hint -->
    <div class="keyboard-hint" id="keyboardHint">
        Use ‚Üê ‚Üí keys to navigate sentences
    </div>

    <div class="page" id="page">
        <!-- Enhanced Header -->
        <header class="topbar">
            <a class="btn" href="../index.html">‚Üê ËøîÂõû</a>
            
            <div class="seg" id="modeSeg">
                <div class="item active" data-mode="full">ÂÖ®ÁØáÁªÉ‰π†</div>
                <div class="item" data-mode="single">ÂçïÂè•ÁªÉ‰π†</div>
            </div>
            
            <button class="btn" id="togglePhonetic"><span class="icon"></span><span class="label">Èü≥Ê†á</span></button>
            <button class="btn" id="toggleScoring"><span class="icon"></span><span class="label">ËØÑÂàÜ</span></button>
            
            <div class="seg" id="accentSeg" title="ÈÄâÊã©Âè£Èü≥">
                <div class="item active" data-accent="us">US ÁæéÈü≥</div>
                <div class="item" data-accent="uk">GB Ëã±Èü≥</div>
            </div>
            <!-- Accent dropdowns -->
            <div class="dropdown" id="usDropdown">
                <div class="dd-item" data-choice="US-Female">US-Female</div>
                <div class="dd-item" data-choice="US-Male">US-Male</div>
            </div>
            <div class="dropdown" id="ukDropdown">
                <div class="dd-item" data-choice="UK-Female">UK-Female</div>
                <div class="dd-item" data-choice="UK-Male">UK-Male</div>
            </div>

        </header>

        <!-- Main Content -->
        <main class="content">
            <!-- Recording Visualization removed: styles deleted -->

            <!-- Full Practice Section -->
            <section id="fullSection"></section>

            <!-- Single Practice Section -->
            <section id="singleSection" hidden>
                <div class="sentence-card">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 12px; color: var(--muted); margin-bottom: 16px;">
                        <button class="btn ghost" id="prevBtn">‚Äπ</button>
                        <span id="pager">1 / 1</span>
                        <button class="btn ghost" id="nextBtn">‚Ä∫</button>
                    </div>
                    <div class="tokens" id="singleTokens"></div>
                </div>
            </section>
            <!-- Scoring Result Section -->
            <section id="scoreSection" hidden>
                <div class="sentence-card" id="scoreCard" style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
                    <div id="scoreSummary" style="text-align:center;padding:8px 0 4px;"></div>
                    <div class="mode-switch" id="scoreModeSwitch" style="margin-top:10px;">
                        <button class="ms-btn" data-mode="basic">Âü∫Á°Ä</button>
                        <button class="ms-btn" data-mode="proxy">ÂêØÂèëÂºèÈü≥Á¥†</button>
                        <button class="ms-btn" data-mode="real">ÁúüÂÆû GOP</button>
                    </div>
                    <div class="chips" id="phonemeChips" style="display:none;"></div>
                    <div class="timeline" id="phonemeTimeline" style="display:none;"></div>
                    <div id="scoreDetails" class="score-details"></div>
                </div>
            </section>
        </main>

        <!-- Enhanced Footer -->
        <footer class="bottombar">
            <div class="speed" id="speedSeg">
                <div class="sitem" data-rate="0.8">ÊÖ¢ÈÄü</div>
                <div class="sitem active" data-rate="1">Ê≠£Â∏∏</div>
                <div class="sitem" data-rate="1.2">Âø´ÈÄü</div>
            </div>
            
            <button class="btn play" id="playBtn">‚ñ∂ Êí≠Êîæ</button>
            <button class="btn record" id="recordBtn">üéô ÂºÄÂßãÂΩïÈü≥</button>
            <button class="btn" id="listenBtn" disabled>üëÇ Âê¨Âê¨ÂõûÊîæ</button>
            <button class="btn" id="resetBtn">‚ü≤ ÈáçÁΩÆ</button>
        </footer>
    </div>

    <script>
        // ===== Score summary helpers (stars + phrase) =====
        function __getStarCount(score){
            const s = Math.round(Math.max(0, Math.min(100, Number(score)||0)) / 20);
            return Math.max(0, Math.min(5, s));
        }
        function __getPhraseByScore(score){
            const s = Math.max(0, Math.min(100, Number(score)||0));
            if (s >= 95) return 'Flawless.';
            if (s >= 90) return 'Outstanding.';
            if (s >= 85) return 'First-rate!';
            if (s >= 80) return 'Awesome!';
            if (s >= 70) return 'Exceeded expectations.';
            if (s >= 60) return "It's alright.";
            if (s >= 50) return 'We can see your progress.';
            if (s >= 40) return 'Keep up the great work.';
            if (s >= 30) return "You've worked so hard.";
            if (s >= 20) return "You'll do better next time.";
            return "The score isn't the most important thing.";
        }
        function __starSVG(on){
            return `<svg viewBox="0 0 24 24" class="star ${on?'on':''}" aria-hidden="true"><path fill="currentColor" d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>`;
        }
        function renderScoreSummary(score){
            const n = Math.round(Number(score)||0);
            const starsOn = __getStarCount(n);
            const stars = Array.from({length:5}, (_,i)=>__starSVG(i < starsOn)).join('');
            const phrase = __getPhraseByScore(n);
            return `\n                <div class="score-number">${n}</div>\n                <div class="stars">${stars}</div>\n                <div class="score-phrase">${phrase}</div>\n            `;
        }

        // Build practice sentences from localStorage (set on home page) with fallback
        function parseSentencesFromText(text){
            if(!text) return [];
            // Normalize whitespace and split by sentence delimiters or newlines
            const cleaned = text.replace(/[\r\t]+/g,' ').replace(/\s+/g,' ').trim();
            const parts = cleaned.replace(/([.!?])\s+/g,'$1\n').split(/[\n;]+/).map(s=>s.trim()).filter(Boolean);
            // Ensure each part is not too short
            return parts.length ? parts : [];
        }
        let storedText = '';
        try { storedText = localStorage.getItem('practice_input_v1') || ''; } catch(e) { storedText = ''; }
        const sentencesFromStorage = parseSentencesFromText(storedText);
        const data = {
            sentences: sentencesFromStorage.length ? sentencesFromStorage : [
                "My family has four people",
                "We live in a big house with a beautiful garden"
            ]
        };

        const defaultDict = {
            my: { us: "/ma…™/", uk: "/ma…™/" },
            family: { us: "/Ààf√¶m…ôli/", uk: "/Ààf√¶m…™li/" },
            has: { us: "/h√¶z/", uk: "/h√¶z/" },
            four: { us: "/f…îÀêr/", uk: "/f…îÀê/" },
            people: { us: "/ÀàpiÀêp…ôl/", uk: "/ÀàpiÀêpl/" },
            we: { us: "/wiÀê/", uk: "/wiÀê/" },
            live: { us: "/l…™v/", uk: "/l…™v/" },
            in: { us: "/…™n/", uk: "/…™n/" },
            a: { us: "/…ô/", uk: "/…ô/" },
            big: { us: "/b…™…°/", uk: "/b…™…°/" },
            house: { us: "/ha äs/", uk: "/ha äs/" },
            with: { us: "/w…™√∞/", uk: "/w…™√∞/" },
            beautiful: { us: "/ÀàbjuÀêt…ôf…ôl/", uk: "/ÀàbjuÀêt…™f…ôl/" },
            garden: { us: "/Àà…°…ëÀêrd…ôn/", uk: "/Àà…°…ëÀêdn/" }
        };

        // Enhanced dictionary management
        function loadDict() {
            try {
                const raw = localStorage.getItem('phoneticsDict');
                if (!raw) {
                    localStorage.setItem('phoneticsDict', JSON.stringify(defaultDict));
                    return { ...defaultDict };
                }
                return { ...defaultDict, ...JSON.parse(raw) };
            } catch (e) {
                console.error('Error loading dictionary:', e);
                return { ...defaultDict };
            }
        }

        function saveDict(dict) {
            try {
                localStorage.setItem('phoneticsDict', JSON.stringify(dict));
                console.log('Dictionary saved successfully');
            } catch (e) {
                try { sessionStorage.setItem('phonetics_skip_persist', '1'); } catch {}
                console.warn('Save dictionary skipped (quota or blocked):', e);
            }
        }

        // Full offline dictionary integration (US/UK)
        const PHONETICS_DICT_VERSION_KEY = 'phoneticsDict_version';
        const PHONETICS_DICT_VERSION = 3; // bump when structure/source changes
        const PHONETICS_SKIP_PERSIST_KEY = 'phonetics_skip_persist';
        const PHONETICS_INMEM_FLAG = 'phonetics_inmem_loaded';

        async function tryFetchJSON(possiblePaths) {
            for (const p of possiblePaths) {
                try {
                    const res = await fetch(p);
                    if (!res.ok) continue;
                    const json = await res.json();
                    console.log('[Dict] Loaded', p, 'entries:', Object.keys(json).length);
                    return json;
                } catch (e) {
                    // try next path
                }
            }
            return null;
        }

        function wrapIPA(s) {
            if (!s || typeof s !== 'string') return '';
            const trimmed = s.trim();
            if (!trimmed) return '';
            return trimmed.startsWith('/') && trimmed.endsWith('/') ? trimmed : `/${trimmed}/`;
        }

        function buildUnifiedDict(usRaw, ukRaw) {
            // Normalize source dictionaries to lowercase keys first
            const normalize = (raw) => {
                const out = {};
                if (!raw) return out;
                for (const k of Object.keys(raw)) {
                    const nk = String(k || '').toLowerCase();
                    if (!(nk in out)) out[nk] = raw[k];
                }
                return out;
            };
            const usN = normalize(usRaw);
            const ukN = normalize(ukRaw);

            const unified = {};
            const keys = new Set([...Object.keys(usN), ...Object.keys(ukN)]);
            for (const key of keys) {
                const usIpa = usN[key];
                const ukIpa = ukN[key];
                const us = usIpa ? wrapIPA(usIpa) : undefined;
                const uk = ukIpa ? wrapIPA(ukIpa) : undefined;
                if (us || uk) unified[key] = { ...(us && { us }), ...(uk && { uk }) };
            }
            // Place minimal defaults first so full dict overrides them
            return { ...defaultDict, ...unified };
        }

        function dictNeedsUpgrade() {
            try {
                const v = Number(localStorage.getItem(PHONETICS_DICT_VERSION_KEY) || '0');
                if (v < PHONETICS_DICT_VERSION) return true;
                const raw = localStorage.getItem('phoneticsDict');
                if (!raw) return true;
                const obj = JSON.parse(raw);
                // Heuristic: full dict should have thousands of entries
                const size = Object.keys(obj || {}).length;
                return size < 1000;
            } catch {
                return true;
            }
        }

        async function ensureFullDictionary() {
            try {
                if (sessionStorage.getItem(PHONETICS_INMEM_FLAG) === '1') return; // already in this session
            } catch {}
            if (!dictNeedsUpgrade()) return; // already loaded
            // Try multiple locations to be robust
            const usPaths = [
                // Verified existing path under project
                '/Old_code/AI Pronunciation Coach/public/data/en_US.json',
                '/Old_code/AI%20Pronunciation%20Coach/public/data/en_US.json',
                '../Old_code/AI Pronunciation Coach/public/data/en_US.json',
                '../Old_code/AI%20Pronunciation%20Coach/public/data/en_US.json',
                '../public/data/en_US.json',
                '../Old_code/AI Pronunciation Coach/src/data/en_US.json',
                '../Old_code/AI%20Pronunciation%20Coach/src/data/en_US.json',
                '/public/data/en_US.json',
                './data/en_US.json',
                'data/en_US.json'
            ];
            const ukPaths = [
                '/Old_code/AI Pronunciation Coach/public/data/en_UK.json',
                '/Old_code/AI%20Pronunciation%20Coach/public/data/en_UK.json',
                '../Old_code/AI Pronunciation Coach/public/data/en_UK.json',
                '../Old_code/AI%20Pronunciation%20Coach/public/data/en_UK.json',
                '../public/data/en_UK.json',
                '../Old_code/AI Pronunciation Coach/src/data/en_UK.json',
                '../Old_code/AI%20Pronunciation%20Coach/src/data/en_UK.json',
                '/public/data/en_UK.json',
                './data/en_UK.json',
                'data/en_UK.json'
            ];
            const [usRaw, ukRaw] = await Promise.all([
                tryFetchJSON(usPaths),
                tryFetchJSON(ukPaths)
            ]);
            if (!usRaw && !ukRaw) {
                console.warn('[Dict] Failed to load full dictionaries, keep default minimal dict.');
                return null;
            }
            const unified = buildUnifiedDict(usRaw || {}, ukRaw || {});
            // Try to persist; if quota exceeded, we still return the full in-memory dict so UI shows all IPA.
            saveDict(unified);
            try { localStorage.setItem(PHONETICS_DICT_VERSION_KEY, String(PHONETICS_DICT_VERSION)); } catch {}
            try { sessionStorage.setItem(PHONETICS_INMEM_FLAG, '1'); } catch {}
            return unified;
        }

        // State management
        let dict = loadDict();
        let accent = 'us';
        let showPhonetic = false;
        let scoringEnabled = true; // ËØÑÂàÜÈªòËÆ§ÂºÄÂêØ
        let mode = 'full';
        let currentIndex = 0;
        let rate = 1;
        let fontSizeTier = 'medium';
        let voiceChoiceUS = 'US-Female';
        let voiceChoiceUK = 'UK-Female';

        // DOM elements
        const fullSection = document.getElementById('fullSection');
        const singleSection = document.getElementById('singleSection');
        const singleTokens = document.getElementById('singleTokens');
        const pager = document.getElementById('pager');
        const togglePhoneticBtn = document.getElementById('togglePhonetic');
        const modeSeg = document.getElementById('modeSeg');
        const accentSeg = document.getElementById('accentSeg');
        const speedSeg = document.getElementById('speedSeg');
        const toggleScoringBtn = document.getElementById('toggleScoring');

        // Eye icons as inline SVG using currentColor so they adapt to state
        const EYE_OPEN_SVG = `<svg viewBox="0 0 80 80" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M59.1999 42.2849C59.1999 49.8593 49.1711 56.0001 36.7999 56.0001C24.4287 56.0001 14.3999 49.8593 14.3999 42.2849C14.3999 34.7105 24.4287 28.5728 36.7999 28.5728C49.1711 28.5728 59.1999 34.7105 59.1999 42.2849Z" stroke="currentColor" stroke-width="4.8" stroke-linecap="round" stroke-linejoin="round"/><path fill-rule="evenodd" clip-rule="evenodd" d="M42.4003 42.2849C42.4471 44.5598 41.1127 46.6369 39.0243 47.5399C36.9357 48.443 34.5085 47.9927 32.8829 46.4007C31.2574 44.8087 30.7567 42.3911 31.6163 40.2846C32.4759 38.1777 34.5248 36.8004 36.8003 36.8001C38.2701 36.7847 39.6861 37.354 40.7363 38.3825C41.7866 39.4113 42.385 40.8148 42.4003 42.2849Z" stroke="currentColor" stroke-width="4.8" stroke-linecap="round" stroke-linejoin="round"/><path d="M34.3998 28.573C34.3998 29.8985 35.4744 30.973 36.7998 30.973C38.1253 30.973 39.1998 29.8985 39.1998 28.573H34.3998ZM39.1998 17.6002C39.1998 16.2747 38.1253 15.2002 36.7998 15.2002C35.4744 15.2002 34.3998 16.2747 34.3998 17.6002H39.1998ZM58.5377 24.1753C59.14 22.9945 58.6709 21.5491 57.4901 20.9469C56.3093 20.3448 54.8638 20.8139 54.2619 21.9947L58.5377 24.1753ZM49.6635 31.0123C49.0613 32.1932 49.5304 33.6386 50.7112 34.2405C51.892 34.8428 53.3374 34.3736 53.9393 33.1929L49.6635 31.0123ZM19.3379 21.9947C18.7357 20.8139 17.2903 20.3448 16.1095 20.9469C14.9287 21.5491 14.4596 22.9945 15.0618 24.1753L19.3379 21.9947ZM19.6602 33.1929C20.2623 34.3736 21.7077 34.8428 22.8885 34.2405C24.0693 33.6386 24.5384 32.1932 23.9363 31.0123L19.6602 33.1929ZM39.1998 28.573V17.6002H34.3998V28.573H39.1998ZM54.2619 21.9947L49.6635 31.0123L53.9393 33.1929L58.5377 24.1753L54.2619 21.9947ZM15.0618 24.1753L19.6602 33.1929L23.9363 31.0123L19.3379 21.9947L15.0618 24.1753Z" fill="currentColor"/></svg>`;
        const EYE_CLOSED_SVG = `<svg viewBox="0 0 80 80" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M40.0002 31.293C41.3256 31.293 42.4002 30.2185 42.4002 28.893C42.4002 27.5675 41.3256 26.493 40.0002 26.493V31.293ZM24.9183 56.1746C26.1015 56.772 27.545 56.2972 28.1425 55.1141C28.74 53.9308 28.2653 52.4872 27.0821 51.8898L24.9183 56.1746ZM37.6002 28.893C37.6002 30.2185 38.6748 31.293 40.0002 31.293C41.3256 31.293 42.4002 30.2185 42.4002 28.893H37.6002ZM42.4002 17.6002C42.4002 16.2747 41.3256 15.2002 40.0002 15.2002C38.6748 15.2002 37.6002 16.2747 37.6002 17.6002H42.4002ZM39.9925 26.493C38.6671 26.4973 37.596 27.5753 37.6002 28.9007C37.6044 30.2262 38.6824 31.2973 40.0079 31.293L39.9925 26.493ZM48.2328 32.3575C49.5135 32.6991 50.8287 31.9378 51.1704 30.6571C51.5119 29.3764 50.7506 28.0613 49.47 27.7197L48.2328 32.3575ZM22.5501 22.1814C21.9609 20.9941 20.5208 20.5092 19.3334 21.0983C18.1461 21.6875 17.6612 23.1276 18.2503 24.315L22.5501 22.1814ZM22.8551 33.595C23.4443 34.7823 24.8844 35.2674 26.0718 34.678C27.2591 34.0888 27.744 32.6488 27.1549 31.4614L22.8551 33.595ZM24.2351 63.974C23.337 64.949 23.3992 66.4671 24.374 67.3653C25.3489 68.2636 26.8672 68.2012 27.7653 67.2264L24.2351 63.974ZM36.0053 58.2824C36.9036 57.3074 36.8412 55.7893 35.8664 54.8911C34.8914 53.9928 33.3733 54.0552 32.4751 55.03L36.0053 58.2824ZM64.166 27.6962C65.0636 26.7211 65.0008 25.2028 64.0258 24.305C63.0508 23.4072 61.5324 23.4699 60.6344 24.445L64.166 27.6962ZM54.1704 31.4658C53.2728 32.4409 53.3356 33.9592 54.3106 34.8572C55.2856 35.7548 56.804 35.692 57.702 34.717L54.1704 31.4658ZM32.4751 55.03C31.577 56.005 31.6392 57.5231 32.614 58.4213C33.589 59.3196 35.1071 59.2572 36.0053 58.2824L32.4751 55.03ZM41.9202 48.3202L43.6853 49.9464L43.6876 49.9439L41.9202 48.3202ZM57.702 34.717C58.5999 33.742 58.5372 32.2239 57.5621 31.326C56.5871 30.4281 55.0684 30.4908 54.1704 31.4658L57.702 34.717ZM34.6338 54.2888C33.3263 54.0712 32.0901 54.9551 31.8727 56.2626C31.6553 57.5701 32.5391 58.8063 33.8466 59.0236L34.6338 54.2888ZM62.4002 43.0114H64.8002C64.8002 42.9544 64.7983 42.8978 64.7941 42.8408L62.4002 43.0114ZM57.0591 30.9702C55.8876 30.3501 54.4351 30.7971 53.8149 31.9685C53.1951 33.14 53.6418 34.5925 54.8133 35.2127L57.0591 30.9702ZM33.5096 47.7336C34.2847 48.8085 35.7848 49.0517 36.86 48.2764C37.9349 47.5013 38.1781 46.0012 37.4028 44.926L33.5096 47.7336ZM40.0002 37.3634L39.9973 34.9634H39.981L40.0002 37.3634ZM41.6735 40.2421C42.7967 40.9458 44.2776 40.6056 44.9813 39.4821C45.685 38.3589 45.3448 36.878 44.2213 36.1743L41.6735 40.2421ZM40.0002 26.493C33.4332 26.493 27.3743 28.1657 22.8813 30.9974C18.4196 33.8095 15.2002 37.996 15.2002 43.0114H20.0002C20.0002 40.2284 21.7952 37.3557 25.4406 35.0581C29.0549 32.7803 34.196 31.293 40.0002 31.293V26.493ZM15.2002 43.0114C15.2002 48.7503 19.3913 53.3836 24.9183 56.1746L27.0821 51.8898C22.3691 49.51 20.0002 46.1877 20.0002 43.0114H15.2002ZM42.4002 28.893V17.6002H37.6002V28.893H42.4002ZM40.0079 31.293C42.7845 31.284 45.55 31.642 48.2328 32.3575L49.47 27.7197C46.3784 26.8951 43.1919 26.4827 39.9925 26.493L40.0079 31.293ZM18.2503 24.315L22.8551 33.595L27.1549 31.4614L22.5501 22.1814L18.2503 24.315ZM27.7653 67.2264L36.0053 58.2824L32.4751 55.03L24.2351 63.974L27.7653 67.2264ZM60.6344 24.445L54.1704 31.4658L57.702 34.717L64.166 27.6962L60.6344 24.445ZM36.0053 58.2824L43.6853 49.9464L40.1551 46.694L32.4751 55.03L36.0053 58.2824ZM43.6876 49.9439L47.1596 46.1647L43.6268 42.9151L40.1528 46.6965L43.6876 49.9439ZM47.1596 46.1647L57.702 34.717L54.1704 31.4658L43.6268 42.9151L47.1596 46.1647ZM33.8466 59.0236C35.8808 59.3621 37.9397 59.5314 40.0018 59.5298L40.0002 54.7298C38.2028 54.7311 36.4069 54.5836 34.6338 54.2888L33.8466 59.0236ZM40.0018 59.5298C46.5688 59.5298 52.6261 57.8572 57.1189 55.0255C61.5807 52.2133 64.8002 48.0268 64.8002 43.0114H60.0002C60.0002 45.7944 58.2053 48.6671 54.5599 50.9647C50.9455 53.2424 45.8044 54.7298 40.0002 54.7298L40.0018 59.5298ZM64.7941 42.8408C64.4364 37.8146 61.5125 33.3278 57.0591 30.9702L54.8133 35.2127C57.8031 36.7954 59.766 39.8076 60.0063 43.182L64.7941 42.8408ZM37.4028 44.926C36.6904 43.9381 36.5887 42.6348 37.1394 41.5484L32.8578 39.3784C31.4957 42.0661 31.7471 45.2895 33.5096 47.7336L37.4028 44.926ZM37.1394 41.5484C37.6901 40.4616 38.8012 39.773 40.0194 39.7634L39.981 34.9634C36.9679 34.9874 34.22 36.6908 32.8578 39.3784L37.1394 41.5484ZM40.0031 39.7634C40.5938 39.7628 41.1727 39.9285 41.6735 40.2421L44.2213 36.1743C42.9554 35.3813 41.4911 34.9615 39.9973 34.9634L40.0031 39.7634Z" fill="currentColor"/></svg>`;

        function setEyeButton(btn, on, label) {
            if (!btn) return;
            btn.innerHTML = `<span class="icon">${on ? EYE_OPEN_SVG : EYE_CLOSED_SVG}</span><span class="label">${label}</span>`;
            btn.classList.toggle('toggled', on);
        }
        const usDropdown = document.getElementById('usDropdown');
        const ukDropdown = document.getElementById('ukDropdown');
        const playBtn = document.getElementById('playBtn');
        const recordBtn = document.getElementById('recordBtn');
        const resetBtn = document.getElementById('resetBtn');
        const listenBtn = document.getElementById('listenBtn');
        const floatingLogo = document.getElementById('floatingLogo');
        const progressBar = document.getElementById('progressBar');
        const keyboardHint = document.getElementById('keyboardHint');
        const recordingViz = null; // removed UI
        // Êñ∞Â¢ûÔºöÂè•Â≠êÁøªÈ°µÊåâÈíÆ
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        // duplicate declarations removed

        // Enhanced floating logo
        function setLogoCompact(compact) {
            floatingLogo.classList.toggle('compact', compact);
            floatingLogo.querySelector('.text').style.display = compact ? 'none' : 'block';
        }

        setLogoCompact(true);
        floatingLogo.addEventListener('click', () => {
            setLogoCompact(!floatingLogo.classList.contains('compact'));
        });

        // Duplicated utility and render functions removed (single source above)

        // Initialize (deduplicated DOM element references are defined earlier)

        // Settings persistence
        const SETTINGS_KEY = 'practice_settings_v1';
        function loadSettings() {
            try {
                const raw = localStorage.getItem(SETTINGS_KEY);
                if (!raw) return;
                const s = JSON.parse(raw);
                if (s.accent) accent = s.accent;
                if (typeof s.showPhonetic === 'boolean') showPhonetic = s.showPhonetic;
                if (typeof s.scoringEnabled === 'boolean') scoringEnabled = s.scoringEnabled;
                if (s.voiceChoiceUS) voiceChoiceUS = s.voiceChoiceUS;
                if (s.voiceChoiceUK) voiceChoiceUK = s.voiceChoiceUK;
                if (s.mode) mode = s.mode;
                if (s.rate) rate = s.rate;
                if (s.fontSizeTier) fontSizeTier = s.fontSizeTier;
                if (Number.isInteger(s.currentIndex)) currentIndex = Math.min(Math.max(0, s.currentIndex), data.sentences.length - 1);
            } catch (e) {
                console.warn('Failed to load settings', e);
            }
        }
        function saveSettings() {
            try {
                localStorage.setItem(SETTINGS_KEY, JSON.stringify({ accent, showPhonetic, scoringEnabled, voiceChoiceUS, voiceChoiceUK, mode, rate, currentIndex, fontSizeTier }));
            } catch (e) {
                console.warn('Failed to save settings', e);
            }
        }
// Ê†πÊçÆ‰∏âÊ°£ËÆæÁΩÆÁº©ÊîæÊØî‰æã
function setContentScale(tier) {
    const scale = tier === 'small' ? 0.9 : (tier === 'large' ? 1.15 : 1);
    document.documentElement.style.setProperty('--content-scale', String(scale));
}

        function tokenize(sentence) {
            return sentence.split(/\s+/).filter(Boolean);
        }

        function getPhonetic(word) {
            const key = word.toLowerCase().replace(/[^a-z']/g, '');
            const entry = dict[key];
            if (!entry) return '';
            return entry[accent] || entry[accent === 'us' ? 'uk' : 'us'] || '';
        }

        // Token renderer (word + IPA) with click-to-speak
        function renderToken(word) {
            const token = document.createElement('div');
            token.className = 'token';
            
            const wordEl = document.createElement('div');
            wordEl.className = 'word';
            wordEl.textContent = word;
            
            const ipaEl = document.createElement('div');
            ipaEl.className = 'ipa';
            const ipaText = getPhonetic(word);
            ipaEl.textContent = ipaText;
            ipaEl.dataset.empty = ipaText ? 'false' : 'true';
            ipaEl.style.display = showPhonetic ? 'block' : 'none';
            
            token.appendChild(wordEl);
            token.appendChild(ipaEl);
            
            // Click actions
            token.addEventListener('click', () => speakWord(word));
            ipaEl.addEventListener('click', (e) => {
                e.stopPropagation();
                speakWord(word);
            });
            
            return token;
        }

        function updateProgress() {
            if (mode === 'single') {
                const progress = ((currentIndex + 1) / data.sentences.length) * 100;
                progressBar.style.width = `${progress}%`;
            } else {
                progressBar.style.width = '100%';
            }
        }

        // Enhanced render function
        function render() {
            setEyeButton(togglePhoneticBtn, showPhonetic, 'Èü≥Ê†á');
            
            updateProgress();
            // Êñ∞Â¢ûÔºöÊ†πÊçÆÊ®°ÂºèÊòæÁ§∫/ÈöêËóèÈîÆÁõòÊèêÁ§∫
            keyboardHint.style.display = (mode === 'single') ? 'block' : 'none';

            if (mode === 'full') {
                singleSection.hidden = true;
                fullSection.hidden = false;
                fullSection.innerHTML = '';
                
                data.sentences.forEach(sentence => {
                    const card = document.createElement('div');
                    card.className = 'sentence-card';
                    
                    const wrapper = document.createElement('div');
                    wrapper.className = 'tokens';
                    
                    tokenize(sentence).forEach(word => {
                        wrapper.appendChild(renderToken(word));
                    });
                    
                    card.appendChild(wrapper);
                    fullSection.appendChild(card);
                });
            } else {
                fullSection.hidden = true;
                singleSection.hidden = false;
                pager.textContent = `${currentIndex + 1} / ${data.sentences.length}`;
                
                singleTokens.innerHTML = '';
                tokenize(data.sentences[currentIndex]).forEach(word => {
                    singleTokens.appendChild(renderToken(word));
                });
            }
            // Â¶ÇÊûúÊ≠£Âú®ÂΩïÈü≥ÔºåÈáçÊñ∞ÁªëÂÆöËØçÈ´ò‰∫Æ
            if (recordBtn && recordBtn.classList.contains('recording')) {
                prepareRecordingHighlight && prepareRecordingHighlight();
            }
        }

        // È°µÈù¢Âä†ËΩΩÂêéÂàùÂßãÂåñÂπ∂È¶ñÊ¨°Ê∏≤Êüì
        try {
            applyUIState();
            render();
        } catch (e) {
            console.error('initial render error:', e);
        }

        // Initialize UI from settings
        loadSettings();
        setContentScale(fontSizeTier);
        render();
        // ÂºÇÊ≠•ÂçáÁ∫ßÂÆåÊï¥ËØçÂÖ∏Âπ∂Âà∑Êñ∞
        ensureFullDictionary().then(nd => { if (nd) { dict = nd; render(); } });
        // ‰øùËØÅÂàáÊç¢Âè£Èü≥Êó∂Ëã•Âè¶‰∏ÄÂè£Èü≥Â≠òÂú®‰πüËÉΩÊòæÁ§∫
        if (accentSeg) {
            accentSeg.addEventListener('click', async (e) => {
                const prev = accent;
                // existing logic may update accent elsewhere; we just ensure dict ready then re-render
                const nd = await ensureFullDictionary();
                if (nd) dict = nd;
                render();
            }, { capture: true });
        }

        // ÂΩïÈü≥ËøáÁ®ãÂçïËØçÈ´ò‰∫ÆÔºöÂü∫‰∫éËØÜÂà´ÁªìÊûúÈÄêËØçÁÇπ‰∫ÆÔºàÂçïÂè•/ÂÖ®ÁØáÂùáÂèØÔºâ
        function clearRecordingHighlight(animate){
            try {
                const st = window.__recHL || {};
                if (st.timer) { clearInterval(st.timer); }
                if (st.recognition) { try { st._stopByApp = true; st.recognition.onresult = null; st.recognition.onend = null; st.recognition.stop(); } catch {} }
                const toks = Array.isArray(st.tokens)?st.tokens:[];
                if (animate) { toks.forEach(el=>{ if (el && el.classList && el.classList.contains('active')) el.classList.add('fadeout'); }); }
                if (toks.length) { toks.forEach(el => el && el.classList && el.classList.remove('active')); }
                if (animate) { setTimeout(()=>{ toks.forEach(el=> el && el.classList && el.classList.remove('fadeout')); }, 800); }
                // Preserve recognized words and normalized tokens for coverage computation
                window.__recHL = Object.assign({}, st, { timer: null, recognition: null });
                // ÂêåÊ≠•ÂÅúÊ≠¢ÂÆûÊó∂ËØ≠Èü≥Èó®Êéß
                try { stopVAD(); } catch {}
                try { if (window.__blueTracker) { window.__blueTracker.idx = -1; window.__blueTracker.setSpeaking(false); } } catch {}
            } catch {}
        }
        function stopRecHighlightEnginesPreserve(){
            try {
                const st = window.__recHL || {};
                if (st.timer) { clearInterval(st.timer); }
                if (st.recognition) { try { st._stopByApp = true; st.recognition.onresult = null; st.recognition.onend = null; st.recognition.stop(); } catch {} }
                window.__recHL = Object.assign({}, st, { timer: null, recognition: null });
                try { stopVAD(); } catch {}
                try { if (window.__blueTracker) { window.__blueTracker.setSpeaking(false); } } catch {}
            } catch {}
        }
        function scheduleBlueClear(ms=5000, animate=true){
            try{
                if (window.__blueClearTimer) { clearTimeout(window.__blueClearTimer); }
                window.__blueClearTimer = setTimeout(()=>{ try { clearRecordingHighlight && clearRecordingHighlight(animate); } catch {} }, ms);
            }catch{}
        }
        class BlueTracker{ constructor(refTokens){ this.ref=Array.isArray(refTokens)?refTokens:[]; this.idx=-1; this.speaking=false; this.lastSpeakingAt=0; this.lastAdvanceAt=0; this.minAdvanceGapMs=70; this.maxSkipInSpeechMs=800; } setSpeaking(on){const now=performance.now(); this.speaking=!!on; if(on) this.lastSpeakingAt=now;} tryAlignAndAdvance(partialTokens){ const now=performance.now(); if(!this.speaking) return false; if(now - this.lastAdvanceAt < this.minAdvanceGapMs) return false; const hyp = Array.isArray(partialTokens)?partialTokens:[]; const norm = s => (s||'').toLowerCase().replace(/^'+|'+$/g,'').replace(/'/g,''); const eq = (a,b) => { try { return typeof fuzzyEqStrict==='function' ? fuzzyEqStrict(norm(a), norm(b)) : (norm(a)===norm(b)); } catch { return norm(a)===norm(b); } }; const start=this.idx+1; const lookAhead=8; const windowRef=this.ref.slice(start, start+lookAhead); let step=0; for(let k=windowRef.length-1;k>=0;k--){ const target=windowRef[k]; if(hyp.some(h=>eq(h,target))){ step=k+1; break; } } if(step>0){ this.idx=Math.min(this.idx+step, this.ref.length-1); this.lastAdvanceAt=now; return true; } if(now - this.lastAdvanceAt > this.maxSkipInSpeechMs){ this.idx=Math.min(this.idx+1, this.ref.length-1); this.lastAdvanceAt=now; return true; } return false; } }
function __syncHighlightFromTracker(){ try{ const st=window.__recHL||{}; const tracker=window.__blueTracker; if(!st.tokens||!tracker) return; const norm=Array.isArray(st.normTokens)?st.normTokens:[]; const targetRaw=Math.max(-1,Math.min(tracker.idx,norm.length-1)); const wsIdx=Array.isArray(st.wordSentenceIdx)?st.wordSentenceIdx:[]; const ranges=Array.isArray(st.sentRanges)?st.sentRanges:[]; const currSent=(typeof st.sentIdx==='number')?st.sentIdx:0; const targetSent=(targetRaw>=0&&wsIdx[targetRaw]!=null)?wsIdx[targetRaw]:currSent; if(typeof targetSent==='number' && targetSent>(st.sentIdx||0)){ st.sentIdx=Math.min(targetSent, ranges.length-1); } const currRange=ranges[st.sentIdx||0] || { first:0, last:norm.length-1 }; const clamped=Math.max(currRange.first-1, Math.min(targetRaw, currRange.last)); if(clamped>=0){ const tIdx=st.wordTokenIndexes[clamped]; const el=st.tokens[tIdx]; if(el&&el.classList) el.classList.add('active'); } st.wordIdx=clamped; window.__recHL=st; }catch(e){} }
function prepareRecordingHighlight(){
            clearRecordingHighlight();
            try {
                if (!recordBtn || !recordBtn.classList.contains('recording')) return;
                // Êî∂ÈõÜ tokensÔºàÂçïÂè•/ÂÖ®ÁØáÔºâ
                const container = (mode === 'single') ? (singleTokens || document) : (fullSection || document);
                const tokens = Array.from(container.querySelectorAll('.sentence-card .tokens .token, .tokens .token, .token'));
                if (!tokens.length) return;
                // ÊèêÂèñÊØè‰∏™ token ÁöÑÊñáÊú¨ÔºåÂπ∂ËßÑËåÉÂåñÔºà‰ªÖ‰øùÁïôÂ≠óÊØçÂíåÊíáÂè∑Ôºâ
                const raw = tokens.map(t => {
                    const w = t.querySelector('.word');
                    return w ? w.textContent : t.textContent;
                });
                const normPerToken = raw.map(w => (w||'').toLowerCase().replace(/[^a-z']/g,''));
                // ‰ªÖÂØπ‚ÄúÊúâËØç‚ÄùÁöÑ token Âª∫Á´ãÁ¥¢ÂºïÊò†Â∞ÑÔºåÈÅøÂÖçÊääÊ†áÁÇπÂΩì‰ΩúËØçÈ´ò‰∫Æ
                const wordTokenIndexes = [];
                const normWords = [];
                normPerToken.forEach((nw, i) => { if (nw) { wordTokenIndexes.push(i); normWords.push(nw); } });
                if (!normWords.length) return;
                try { window.__blueTracker = new BlueTracker(normWords); } catch {}
                // Re-start VAD after re-prepare so fallback timer and tracker speaking state work for subsequent sentences
                try {
                    if (recordBtn && recordBtn.classList.contains('recording')) {
                        if (typeof mediaStream !== 'undefined' && mediaStream) {
                            startVAD(mediaStream);
                        } else {
                            // If no mediaStream (e.g., SR-only path), do not block fallback timers
                            window.__vadSpeaking = undefined;
                        }
                    }
                } catch {}


                // Âè•Â≠êËæπÁïåÊò†Â∞ÑÔºöÊääÊØè‰∏™ËØçÊò†Â∞ÑÂà∞ÂÖ∂ÊâÄÂ±û sentence-cardÔºåÁîüÊàêÊØèÂè•ËØçËåÉÂõ¥
                const sentenceCards = Array.from(container.querySelectorAll('.sentence-card'));
                const cardIndexMap = new Map(sentenceCards.map((c,i)=>[c,i]));
                const wordSentenceIdx = wordTokenIndexes.map(tIdx => {
                    const card = tokens[tIdx]?.closest('.sentence-card');
                    const i = cardIndexMap.get(card);
                    return (typeof i === 'number') ? i : 0;
                });
                const sentRanges = [];
                const maxSent = wordSentenceIdx.reduce((a,b)=>Math.max(a,b),0);
                for (let s=0; s<=maxSent; s++){
                    let first=-1,last=-1;
                    for (let i=0;i<wordSentenceIdx.length;i++){
                        if (wordSentenceIdx[i]===s){ if (first<0) first=i; last=i; }
                    }
                    sentRanges[s] = { first, last };
                }
                let sentIdx = 0; // ÂΩìÂâçÂè•Á¥¢Âºï
                const prevSt = window.__recHL || {};
                if (typeof prevSt.sentIdx === 'number') sentIdx = Math.min(prevSt.sentIdx, Math.max(0, sentRanges.length-1));

                let wordIdx = -1; // ËØçÁ∫ßÁ¥¢Âºï
                const addActiveAt = (wi) => {
                    const tIdx = wordTokenIndexes[wi];
                    if (tokens[tIdx] && tokens[tIdx].classList) tokens[tIdx].classList.add('active');
                };
                const removeActiveAt = (wi) => {
                    const tIdx = wordTokenIndexes[wi];
                    if (tIdx != null && tokens[tIdx] && tokens[tIdx].classList) tokens[tIdx].classList.remove('active');
                };
                const getCurrRange = ()=> sentRanges[sentIdx] || { first: 0, last: normWords.length - 1 };
                const advanceWord = () => {
                    const range = getCurrRange();
                    const target = Math.min((wordIdx < range.first - 1 ? range.first : wordIdx + 1), range.last);
                    // keep blue: do not removeActiveAt(wordIdx)
                    wordIdx = target;
                    addActiveAt(wordIdx);
                    const st = window.__recHL || {}; st.wordIdx = wordIdx; st.sentIdx = sentIdx; window.__recHL = st;
                    try { if (window.__blueTracker) { window.__blueTracker.idx = Math.max(window.__blueTracker.idx, wordIdx); } } catch {}
                    try { __syncHighlightFromTracker(); } catch {}
                    // fallback timer path: auto advance to next sentence when reaching end of current sentence
                    if ((!st.recognition) && wordIdx >= range.last) {
                        const nr = sentRanges[sentIdx + 1];
                        if (nr && nr.first >= 0) {
                            // keep blue: do not remove previous active when moving to next sentence
                            sentIdx = sentIdx + 1;
                            wordIdx = nr.first;
                            addActiveAt(wordIdx);
                            st.wordIdx = wordIdx; st.sentIdx = sentIdx; window.__recHL = st;
                            try { if (window.__blueTracker) { window.__blueTracker.idx = Math.max(window.__blueTracker.idx, wordIdx); } } catch {}
                            try { __syncHighlightFromTracker(); } catch {}
                        }
                    }
                };
                // Web Speech ËØÜÂà´‰ºòÂÖàÔºåÂÖ∂Ê¨°ÈÄÄÂåñ‰∏∫ÁÆÄÂçïÁöÑÊó∂Èó¥Êé®Ëøõ
                const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (SR) {
                    const rec = new SR();
                    rec.continuous = true;
                    rec.interimResults = true;
                    rec.maxAlternatives = 1;
                    rec.lang = (accent === 'uk') ? 'en-GB' : 'en-US';

                    // ‰ªÖÁî®‚ÄúÊúÄÁªàÁªìÊûú‚ÄùÊé®ËøõÔºõÁü≠ËØç(<=3)‰∏•Ê†ºÂåπÈÖçÔºõÂä†ÂÖ•Ë∑≥ËØªÂâçÁûª
                    function fuzzyEqStrict(a, b){
                        const A = (a||'').replace(/'/g,'');
                        const B = (b||'').replace(/'/g,'');
                        if (A.length <= 3 || B.length <= 3) return A === B;
                        const lev1 = (x,y)=>{
                            const m=x.length,n=y.length; if (Math.abs(m-n)>1) return false;
                            let i=0,j=0,d=0; while(i<m && j<n){ if(x[i]===y[j]){ i++; j++; } else { if(++d>1) return false; if(m>n) i++; else if(n>m) j++; else { i++; j++; } } }
                            return true;
                        };
                        return A===B || lev1(A,B);
                    }
                    function processTranscript(txt, commit=false) {
                        const fillers = new Set(['uh','um','er','erm','ah','eh','hmm','mm','mmm']);
                        const norm = s => (s||'').toLowerCase().replace(/^'+|'+$/g,'');
                        let parts = (txt||'').toLowerCase().match(/[a-z']+/g) || [];
                        parts = parts.map(norm).filter(Boolean).filter(p=>!fillers.has(p));
                        const st = window.__recHL || {};
                        if (!Array.isArray(st.recWords)) st.recWords = [];
                        if (parts.length) st.recWords.push(...parts);
                        // trim recognition history to avoid drift/memory growth
                        st.recWords = (mode === 'single') ? st.recWords.slice(-80) : st.recWords.slice(-200);
                        // allow interim (non-final) results to advance highlight for better responsiveness

                        const normWords = Array.isArray(st.normTokens) ? st.normTokens : [];
                        const lookback = (mode === 'single') ? 28 : 40;
                        const win = st.recWords.slice(-lookback);
                        const currRange = (Array.isArray(st.sentRanges)?st.sentRanges:[])[st.sentIdx||0] || { first: 0, last: normWords.length-1 };

                        // VAD Èó®ÊéßÔºö‰ªÖÂØπ BlueTracker ÂØπÈΩêÂ∞ùËØïÁîüÊïàÔºõÂü∫‰∫é ASR ÁöÑÊé®Ëøõ‰∏çË¢´Êó©Êúü VAD ÈòªÊñ≠
                        const vadOk = (typeof window.__vadSpeaking === 'boolean') ? window.__vadSpeaking : true;
                        try { if (vadOk && window.__blueTracker && window.__blueTracker.tryAlignAndAdvance(win)) { __syncHighlightFromTracker(); } } catch {}

                        while (st.wordIdx + 1 <= currRange.last) {
                            const expect = normWords[st.wordIdx + 1];
                            const hit = win.some(w => fuzzyEqStrict(w, expect));
                            if (!hit) break;
                            if (st.wordIdx >= 0) {
                                const tIdxPrev = st.wordTokenIndexes[st.wordIdx];
                                const prevEl = st.tokens[tIdxPrev]; /* keep blue: do not remove previous active */
                            }
                            st.wordIdx = Math.min(st.wordIdx + 1, currRange.last);
                            const tIdx = st.wordTokenIndexes[st.wordIdx];
                            const el = st.tokens[tIdx]; el && el.classList && el.classList.add('active');
                            st.__noHit = 0;
                            try { if (window.__blueTracker) { window.__blueTracker.idx = Math.max(window.__blueTracker.idx, st.wordIdx); } } catch {}
                            try { __syncHighlightFromTracker(); } catch {}
                        }
                        // ÂâçÁûªË∑≥Ë∑ÉÔºàÂÖÅËÆ∏Ë∑≥ËøáËã•Âπ≤Êú™ËØªËØçÁªßÁª≠Êé®ËøõÔºâ‚Äî‚Äî ‰ªÖÈôê‚ÄúÂΩìÂâçÂè•‚ÄùËåÉÂõ¥ÂÜÖÔºõÂçïÂè•Ê®°ÂºèÂêØÁî®ÊúâÈôêÂâçÁûª‰ª•ÊèêÂçáËØÜÂà´Âè¨Âõû
                        if (st.wordIdx + 1 <= currRange.last){
                            st.__noHit = (st.__noHit||0) + 1;
                            const nextN = (mode === 'single') ? 2 : 6;  // ÂçïÂè•Êõ¥‰øùÂÆàÔºåÂÖ®ÁØáÊõ¥ÁßØÊûÅ
                            const needNoHit = 1; // Èôç‰ΩéÈó®ÊßõÔºåÊèêÂçáÂè¨Âõû
                            if (st.__noHit >= needNoHit){
                                const ahead = [];
                                for (let k=1; k<=nextN && st.wordIdx + k <= currRange.last; k++){
                                    ahead.push({ k, w: normWords[st.wordIdx + k] });
                                }
                                const found = ahead.find(a => win.some(w => fuzzyEqStrict(w, a.w)));
                                if (found){
                                    if (st.wordIdx >= 0){
                                        const tIdxPrev = st.wordTokenIndexes[st.wordIdx];
                                        const prevEl = st.tokens[tIdxPrev]; /* keep blue: do not remove previous active */
                                    }
                                    st.wordIdx = Math.min(st.wordIdx + found.k, currRange.last);
                                    const tIdx = st.wordTokenIndexes[st.wordIdx];
                                    const el = st.tokens[tIdx]; el && el.classList && el.classList.add('active');
                                    st.__noHit = 0;
                                    try { if (window.__blueTracker) { window.__blueTracker.idx = Math.max(window.__blueTracker.idx, st.wordIdx); } } catch {}
                                    try { __syncHighlightFromTracker(); } catch {}
                                }
                            }
                        } else {
                            st.__noHit = 0;
                        }
                        // ËäÇÂ•èÊé®ËøõÂÖúÂ∫ïÔºöÊåÅÁª≠ËØ¥ËØù‰ΩÜËøëÊúüÊó†ÂëΩ‰∏≠Êó∂ÔºåÂè•ÂÜÖ+1Êé®ËøõÔºåÂ∏ÆÂä©Âø´ËØ≠ÈÄüË∑ü‰∏ä
                        {
                            const speaking = (typeof window.__vadSpeaking === 'boolean') ? window.__vadSpeaking : true;
                            window.__lastRhythmStep = window.__lastRhythmStep || 0;
                            const nowTS = performance.now();
                            if (speaking && st.wordIdx + 1 <= currRange.last) {
                                const gapMs = 240; // ‰∏é BlueTracker ÂàÜÁ¶ªÔºåÁ®ç‰øùÂÆà
                                if (nowTS - window.__lastRhythmStep > gapMs) {
                                    st.wordIdx = Math.min(st.wordIdx + 1, currRange.last);
                                    const tIdx = st.wordTokenIndexes[st.wordIdx];
                                    const el = st.tokens[tIdx]; el && el.classList && el.classList.add('active');
                                    try { if (window.__blueTracker) { window.__blueTracker.idx = Math.max(window.__blueTracker.idx, st.wordIdx); } } catch {}
                                    try { __syncHighlightFromTracker(); } catch {}
                                    window.__lastRhythmStep = nowTS;
                                }
                            }
                        }

                        // Ë∑®Âè•Êé®ËøõÔºöÂΩìÂΩìÂâçÂè•Â∑≤ÂÆåÊàêÔºåÊ£ÄÊµãÂà∞‰∏ã‰∏ÄÂè•Ëµ∑ÂßãËØç(ÊàñÁ¨¨‰∫åËØç)Âç≥ÂèØËøõÂÖ•‰∏ã‰∏ÄÂè•ÔºàÂÖÅËÆ∏‰∏¥Êó∂ÊàñÊúÄÁªàÁªìÊûúËß¶ÂèëÔºâ
                        const nextRange = (Array.isArray(st.sentRanges)?st.sentRanges:[])[(st.sentIdx||0)+1];
                        if (nextRange && nextRange.first >= 0 && st.wordIdx >= currRange.last){
                            const nextFirst = normWords[nextRange.first];
                            const nextSecond = (nextRange.first + 1 <= nextRange.last) ? normWords[nextRange.first + 1] : null;
                            const trigger = (win.some(w => fuzzyEqStrict(w, nextFirst)) || (nextSecond && win.some(w => fuzzyEqStrict(w, nextSecond))));
                            if (trigger){
                                if (st.wordIdx >= 0){
                                    const tIdxPrev = st.wordTokenIndexes[st.wordIdx];
                                    const prevEl = st.tokens[tIdxPrev]; /* keep blue: do not remove previous active */
                                }
                                st.sentIdx = (st.sentIdx||0) + 1;
                                st.wordIdx = nextRange.first;
                                const tIdx = st.wordTokenIndexes[st.wordIdx];
                                const el = st.tokens[tIdx]; el && el.classList && el.classList.add('active');
                                st.__noHit = 0;
                                try { if (window.__blueTracker) { window.__blueTracker.idx = Math.max(window.__blueTracker.idx, st.wordIdx); } } catch {}
                                try { __syncHighlightFromTracker(); } catch {}
                            }
                        }
                        window.__recHL = st;
                    }
                    rec.onresult = (e) => {
                        for (let i = e.resultIndex; i < e.results.length; i++) {
                            const r = e.results[i];
                            processTranscript(r[0]?.transcript || '', r.isFinal === true);
                        }
                    };
                    rec.onerror = (e) => {
                        console.warn('SpeechRecognition error:', e);
                        try { rec.onresult = null; rec.onend = null; rec.stop(); } catch {}
                        // ÂõûÈÄÄÂà∞ËÆ°Êó∂Êé®Ëøõ
                        const st = window.__recHL || { tokens, normTokens: normWords, wordTokenIndexes, wordIdx, wordSentenceIdx, sentRanges, sentIdx };
                        const base = 350;
                        const stepMs = Math.max(150, Math.min(900, Math.round(base / (rate || 1))));
                        function step() {
                            if (!recordBtn || !recordBtn.classList.contains('recording')) { stopRecHighlightEnginesPreserve(); return; }
                            const vadKnown = (typeof window.__vadSpeaking === 'boolean');
                            if (vadKnown && !window.__vadSpeaking) return;
                            advanceWord();
                        }
                        st.timer = setInterval(step, stepMs);
                        st.recognition = null;
                        st._stopByApp = false;
                        st.lastParts = st.lastParts || [];
                        st.recWords = (mode === 'single') ? [] : (Array.isArray(st.recWords) ? st.recWords.slice(-200) : []);
                        window.__recHL = st;
                        step();
                    };
                    rec.onend = () => {
                        const st = window.__recHL || {};
                        if (recordBtn && recordBtn.classList.contains('recording') && !st._stopByApp) {
                            setTimeout(()=>{ 
                                try { rec.start(); } catch (e) { 
                                    // ÈáçÂêØÂ§±Ë¥•‚ÜíÂõûÈÄÄËÆ°Êó∂Êé®Ëøõ
                                    const st2 = window.__recHL || { tokens, normTokens: normWords, wordTokenIndexes, wordIdx, wordSentenceIdx, sentRanges, sentIdx };
                                    const base=350; const stepMs = Math.max(150, Math.min(900, Math.round(base / (rate || 1))));
                                    function step(){ if (!recordBtn || !recordBtn.classList.contains('recording')) { stopRecHighlightEnginesPreserve(); return; } const vadKnown = (typeof window.__vadSpeaking === 'boolean'); if (vadKnown && !window.__vadSpeaking) return; advanceWord(); }
                                    st2.timer = setInterval(step, stepMs);
                                    st2.recognition = null;
                                    st2._stopByApp = false;
                                    st2.lastParts = st2.lastParts || [];
                                    st2.recWords = (mode === 'single') ? [] : (Array.isArray(st2.recWords) ? st2.recWords.slice(-200) : []);
                                    window.__recHL = st2;
                                    step();
                                } 
                            }, 120);
                        }
                    };
                    // ÂÖàÂª∫Á´ãÁä∂ÊÄÅÔºåÂÜçÂêØÂä®ËØÜÂà´ÔºàÂçïÂè•Ê®°ÂºèÈáçÁΩÆËØÜÂà´ËØçÂéÜÂè≤ÔºõÂÖ®ÁØáÊ®°Âºè‰øùÁïôÊúÄËøë200‰∏™ÔºåÈò≤Ê≠¢ÂéÜÂè≤ÂØºËá¥Ë∑≥ËØçÊàñÂÜÖÂ≠òÂ¢ûÈïøÔºâ
                    const prevWords = (mode === 'single') ? [] : (Array.isArray((window.__recHL||{}).recWords) ? (window.__recHL||{}).recWords.slice(-200) : []);
                    window.__recHL = { tokens, normTokens: normWords, wordTokenIndexes, wordSentenceIdx, sentRanges, sentIdx, wordIdx, recognition: rec, _stopByApp: false, timer: null, lastParts: [], recWords: prevWords };
                    try { rec.start(); } catch (e) { 
                        // start ÊäõÈîôÔºàÂ∏∏ËßÅ‰∫éÊùÉÈôêÊãíÁªùÊàñÊµèËßàÂô®ÈôêÂà∂Ôºâ‚Üí ÂõûÈÄÄ
                        const st = window.__recHL || { tokens, normTokens: normWords, wordTokenIndexes, wordSentenceIdx, sentRanges, sentIdx, wordIdx };
                        const base=350; const stepMs = Math.max(150, Math.min(900, Math.round(base / (rate || 1))));
                        function step(){ if (!recordBtn || !recordBtn.classList.contains('recording')) { stopRecHighlightEnginesPreserve(); return; } const vadKnown = (typeof window.__vadSpeaking === 'boolean'); if (vadKnown && !window.__vadSpeaking) return; advanceWord(); }
                        st.timer = setInterval(step, stepMs);
                        st.recognition = null;
                        st._stopByApp = false;
                        st.lastParts = st.lastParts || [];
                        st.recWords = (mode === 'single') ? [] : (Array.isArray(st.recWords) ? st.recWords.slice(-200) : []);
                        window.__recHL = st;
                        step();
                    }
                } else {
                    // FallbackÔºöÊó†ËØÜÂà´APIÊó∂ÊåâËØ≠ÈÄüÊåâ‚ÄúËØç‚ÄùÊé®ËøõÔºàÈÄÄÂåñ‰ΩìÈ™åÔºâ
                    const base = 350;
                    const stepMs = Math.max(150, Math.min(900, Math.round(base / (rate || 1))));
                    function step() {
                        if (!recordBtn || !recordBtn.classList.contains('recording')) { stopRecHighlightEnginesPreserve(); return; }
                        const vadKnown = (typeof window.__vadSpeaking === 'boolean');
                        if (vadKnown && !window.__vadSpeaking) return;
                        advanceWord();
                    }
                    window.__recHL = { tokens, normTokens: normWords, wordTokenIndexes, wordSentenceIdx, sentRanges, sentIdx, wordIdx, timer: setInterval(step, stepMs), recognition: null, _stopByApp: false, lastParts: [], recWords: (mode === 'single') ? [] : [] };
                    step();
                }
            } catch {}
        }

        // LCS-based coverage from recording highlight state
        function __computeCoverageFromRecHL(){
            const st = window.__recHL || {};
            const ref = Array.isArray(st.normTokens) ? st.normTokens : [];
            const hyp = Array.isArray(st.recWords) ? st.recWords : [];
            if (!ref.length || !hyp.length) return { pct: 0, matched: 0, refCount: ref.length };

            const R = ref.length, H = hyp.length;
            const dp = Array.from({length:R+1}, ()=> new Uint16Array(H+1));
            for (let i=1;i<=R;i++){
                const ri = ref[i-1];
                for (let j=1;j<=H;j++){
                    const hj = hyp[j-1];
                    const eq = (ri===hj) || (ri.replace(/'/g,'')===hj.replace(/'/g,'')); // ÂøΩÁï•ÊíáÂè∑
                    dp[i][j] = eq ? (dp[i-1][j-1]+1) : Math.max(dp[i-1][j], dp[i][j-1]);
                }
            }
            const matched = dp[R][H];
            const pct = Math.round(matched / Math.max(1, R) * 100);
            return { pct, matched, refCount: R };
        }

        // Êñ∞Â¢ûÔºöÊéß‰ª∂‰∫ã‰ª∂ÁªëÂÆö‰∏é UI Áä∂ÊÄÅÂêåÊ≠•
        function applyUIState() {
            // Ê®°ÂºèÂàÜÊÆµ
            Array.from(modeSeg.querySelectorAll('.item')).forEach(el => {
                el.classList.toggle('active', el.dataset.mode === mode);
            });
            // Âè£Èü≥ÂàÜÊÆµ
            Array.from(accentSeg.querySelectorAll('.item')).forEach(el => {
                el.classList.toggle('active', el.dataset.accent === accent);
            });
            // ËØ≠ÈÄüÂàÜÊÆµ
            Array.from(speedSeg.querySelectorAll('.sitem')).forEach(el => {
                el.classList.toggle('active', parseFloat(el.dataset.rate) === rate);
            });
            // ÊñáÊ°à
            setEyeButton(togglePhoneticBtn, showPhonetic, 'Èü≥Ê†á');
            if (typeof scoringEnabled !== 'undefined' && toggleScoringBtn) {
                setEyeButton(toggleScoringBtn, scoringEnabled, 'ËØÑÂàÜ');
            }
            const usItem = accentSeg.querySelector('.item[data-accent="us"]');
            const ukItem = accentSeg.querySelector('.item[data-accent="uk"]');
            if (usItem) usItem.textContent = 'US ÁæéÈü≥' + (voiceChoiceUS ? (' ¬∑ ' + String(voiceChoiceUS).replace('US-','')) : '');
            if (ukItem) ukItem.textContent = 'GB Ëã±Èü≥' + (voiceChoiceUK ? (' ¬∑ ' + String(voiceChoiceUK).replace('UK-','')) : '');
            keyboardHint.style.display = (mode === 'single') ? 'block' : 'none';
            // ËØÑÂàÜÂºÄÂÖ≥Âç≥Êó∂ UI ÂêåÊ≠•ÔºöÂÖ≥Èó≠Êó∂Ê∏ÖÁ©∫Âπ∂ÈöêËóèËØÑÂàÜÂç°
            try {
                if (typeof scoringEnabled !== 'undefined' && !scoringEnabled) {
                    const scoreSection = document.getElementById('scoreSection');
                    const scoreSummary = document.getElementById('scoreSummary');
                    const scoreDetails = document.getElementById('scoreDetails');
                    if (typeof clearAccuracyHighlights === 'function') { try { clearAccuracyHighlights(); } catch {} }
                    if (scoreSummary) scoreSummary.textContent = '';
                    if (scoreDetails) scoreDetails.textContent = '';
                    if (scoreSection) scoreSection.hidden = true;
                }
            } catch {}
        }

        // ÁÇπÂáªÂàáÊç¢Ê®°Âºè
        modeSeg.addEventListener('click', (e) => {
            const item = e.target.closest('.item');
            if (!item) return;
            mode = item.dataset.mode === 'single' ? 'single' : 'full';
            applyUIState();
            saveSettings();
            render();
        });

        // ÂàáÊç¢Âè£Èü≥
        accentSeg.addEventListener('click', (e) => {
            const item = e.target.closest('.item');
            if (!item) return;
            const acc = item.dataset.accent;
            if (acc === 'us' || acc === 'uk') accent = acc;
            applyUIState();
            saveSettings();
            render();
            // ÊâìÂºÄÂØπÂ∫î‰∏ãÊãâ
            try { if (item) { const r=item.getBoundingClientRect(); const dd=(accent==='uk'?ukDropdown:usDropdown); if(dd){ dd.style.left=(r.left+window.scrollX)+'px'; dd.style.top=(r.bottom+window.scrollY+6)+'px'; dd.style.display='block'; } } } catch{}
        });

        // ÂàáÊç¢ËØ≠ÈÄü
        speedSeg.addEventListener('click', (e) => {
            const item = e.target.closest('.sitem');
            if (!item) return;
            const r = parseFloat(item.dataset.rate);
            if (!Number.isNaN(r)) rate = r;
            applyUIState();
            saveSettings();
        });

        // ÂàáÊç¢Èü≥Ê†áÊòæÁ§∫
        togglePhoneticBtn.addEventListener('click', () => {
            showPhonetic = !showPhonetic;
            applyUIState();
            saveSettings();
            render();
        });

        // ËØÑÂàÜÂºÄÂÖ≥
        toggleScoringBtn && toggleScoringBtn.addEventListener('click', () => {
            scoringEnabled = !scoringEnabled;
            applyUIState();
            saveSettings();
            // Ëã•ÈáçÊñ∞ÂºÄÂêØËØÑÂàÜ‰∏îÂ∑≤ÊúâÊúÄËøë‰∏ÄÊ¨°ÂΩïÈü≥ÔºåÂàôÁ´ãÂç≥Âà∑Êñ∞ËØÑÂàÜ
            try {
                if (scoringEnabled && typeof lastRecordedBlob !== 'undefined' && lastRecordedBlob && !window.__scoringBusy) {
                    computeAndRenderScore(lastRecordedBlob);
                }
            } catch {}
        });

        // ‰∏ãÊãâËèúÂçï‰∫§‰∫íÔºàUS/UK ÊÄßÂà´Ôºâ
        function __hideAccentDropdowns(){ try { if (usDropdown) usDropdown.style.display = 'none'; if (ukDropdown) ukDropdown.style.display = 'none'; } catch {} }
        usDropdown && usDropdown.addEventListener('click', (e) => {
            const item = e.target.closest('.dd-item');
            if (!item) return;
            const v = item.dataset.choice;
            if (v) voiceChoiceUS = v;
            __hideAccentDropdowns();
            applyUIState();
            saveSettings();
        });
        ukDropdown && ukDropdown.addEventListener('click', (e) => {
            const item = e.target.closest('.dd-item');
            if (!item) return;
            const v = item.dataset.choice;
            if (v) voiceChoiceUK = v;
            __hideAccentDropdowns();
            applyUIState();
            saveSettings();
        });
        // ÁÇπÂáªÂ§ñÈÉ®ÂÖ≥Èó≠‰∏ãÊãâ
        document.addEventListener('click', (e) => {
            const inSeg = e.target.closest('#accentSeg');
            const inDD = e.target.closest('#usDropdown') || e.target.closest('#ukDropdown');
            if (!inSeg && !inDD) __hideAccentDropdowns();
        });

        // Âè•Â≠êÁøªÈ°µÔºàÂçïÂè•Ê®°ÂºèÔºâ
        function clampIndex(i){
            return Math.max(0, Math.min(i, data.sentences.length - 1));
        }
        prevBtn && prevBtn.addEventListener('click', () => {
            if (mode !== 'single') return;
            currentIndex = clampIndex(currentIndex - 1);
            saveSettings();
            render();
        });
        nextBtn && nextBtn.addEventListener('click', () => {
            if (mode !== 'single') return;
            currentIndex = clampIndex(currentIndex + 1);
            saveSettings();
            render();
        });

        // ÈîÆÁõòÂØºËà™
        document.addEventListener('keydown', (e) => {
            if (mode !== 'single') return;
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                currentIndex = clampIndex(currentIndex - 1);
                saveSettings();
                render();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                currentIndex = clampIndex(currentIndex + 1);
                saveSettings();
                render();
            }
        });

        // Êí≠ÊîæÊñáÊú¨
        playBtn.addEventListener('click', () => {
            const text = mode === 'single' ? (data.sentences[currentIndex] || '') : data.sentences.join('. ');
            speakText(text);
        });

        // ÊóßÁöÑ‚ÄúÁÆÄÊòìÂΩïÈü≥ÊåâÈíÆ‚ÄùÁõëÂê¨Âô®Â∑≤ÁßªÈô§ÔºåÈÅøÂÖç‰∏éÁªü‰∏ÄÊçïËé∑Èò∂ÊÆµÁªëÂÆöÂÜ≤Á™Å„ÄÇ

        // ÈáçÁΩÆÔºà‰ªÖÈáçÁΩÆÂΩïÈü≥/ÂõûÊîæ‰∏éËØÑÂàÜÁä∂ÊÄÅÔºå‰∏çÂΩ±ÂìçÊ®°Âºè/Èü≥Ê†á/Ëã±ÁæéÈü≥Á≠âËÆæÁΩÆÔºâ
        resetBtn.addEventListener('click', () => {
            try {
                if (typeof stopSpeaking === 'function') stopSpeaking();
                if (typeof stopPlayback === 'function') stopPlayback();
                if (recordBtn && recordBtn.classList && recordBtn.classList.contains('recording')) {
                    try { if (typeof stopRecording === 'function') stopRecording(true); } catch {}
                }
                if (recordBtn && recordBtn.classList) { recordBtn.classList.remove('recording'); recordBtn.textContent = 'üéô ÂºÄÂßãÂΩïÈü≥'; }
                if (recordedAudioUrl) { try { URL.revokeObjectURL(recordedAudioUrl); } catch {} }
                recordedAudioUrl = null;
                lastRecordedBlob = null;
                if (listenBtn) listenBtn.disabled = true;
                try { if (typeof clearRecordingHighlight === 'function') clearRecordingHighlight(); } catch {}
                try { if (typeof clearAccuracyHighlights === 'function') clearAccuracyHighlights(); } catch {}
                try {
                    __lastScoring = null;
                    const scoreSection = document.getElementById('scoreSection');
                    const scoreSummary = document.getElementById('scoreSummary');
                    const scoreDetails = document.getElementById('scoreDetails');
                    if (scoreSummary) scoreSummary.textContent = '';
                    if (scoreDetails) scoreDetails.textContent = '';
                    if (scoreSection) scoreSection.hidden = true;
                } catch {}
            } catch {}
        });
        /* DUPLICATE BLOCK REMOVED - mid start
        // Initialize UI from settings
        loadSettings();
        setContentScale(fontSizeTier);
        render();
        // ÂºÇÊ≠•ÂçáÁ∫ßÂÆåÊï¥ËØçÂÖ∏Âπ∂Âà∑Êñ∞
        ensureFullDictionary().then(nd => { if (nd) { dict = nd; render(); } });
        // Enhanced render function
        function render() {
            setEyeButton(togglePhoneticBtn, showPhonetic, 'Èü≥Ê†á');
            updateProgress();

            if (mode === 'full') {
                singleSection.hidden = true;
                fullSection.hidden = false;
                fullSection.innerHTML = '';
                
                data.sentences.forEach(sentence => {
                    const card = document.createElement('div');
                    card.className = 'sentence-card';
                    
                    const wrapper = document.createElement('div');
                    wrapper.className = 'tokens';
                    
                    tokenize(sentence).forEach(word => {
                        wrapper.appendChild(renderToken(word));
                    });
                    
                    card.appendChild(wrapper);
                    fullSection.appendChild(card);
                });
            } else {
                fullSection.hidden = true;
                singleSection.hidden = false;
                pager.textContent = `${currentIndex + 1} / ${data.sentences.length}`;
                
                singleTokens.innerHTML = '';
                tokenize(data.sentences[currentIndex]).forEach(word => {
                    singleTokens.appendChild(renderToken(word));
                });
            }
            // if recording, re-bind highlight to the new DOM
            if (recordBtn.classList.contains('recording')) {
                prepareRecordingHighlight();
            }
        }

        // ÁÇπÂáªÂàáÊç¢Ê®°Âºè
        modeSeg.addEventListener('click', (e) => {
            const item = e.target.closest('.item');
            if (!item) return;
            mode = item.dataset.mode === 'single' ? 'single' : 'full';
            applyUIState();
            saveSettings();
            render();
        });

        // ÂàáÊç¢Âè£Èü≥
        accentSeg.addEventListener('click', (e) => {
            const item = e.target.closest('.item');
            if (!item) return;
            const acc = item.dataset.accent;
            if (acc === 'us' || acc === 'uk') accent = acc;
            applyUIState();
            saveSettings();
            render();
        });

        // ÂàáÊç¢ËØ≠ÈÄü
        speedSeg.addEventListener('click', (e) => {
            const item = e.target.closest('.sitem');
            if (!item) return;
            const r = parseFloat(item.dataset.rate);
            if (!Number.isNaN(r)) rate = r;
            applyUIState();
            saveSettings();
        });

        // ÂàáÊç¢Èü≥Ê†áÊòæÁ§∫
        togglePhoneticBtn.addEventListener('click', () => {
            showPhonetic = !showPhonetic;
            applyUIState();
            saveSettings();
            render();
        });

        // Âè•Â≠êÁøªÈ°µÔºàÂçïÂè•Ê®°ÂºèÔºâ
        function clampIndex(i){
            return Math.max(0, Math.min(i, data.sentences.length - 1));
        }
        prevBtn && prevBtn.addEventListener('click', () => {
            if (mode !== 'single') return;
            currentIndex = clampIndex(currentIndex - 1);
            saveSettings();
            render();
        });
        nextBtn && nextBtn.addEventListener('click', () => {
            if (mode !== 'single') return;
            currentIndex = clampIndex(currentIndex + 1);
            saveSettings();
            render();
        });

        // ÈîÆÁõòÂØºËà™
        document.addEventListener('keydown', (e) => {
            if (mode !== 'single') return;
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                currentIndex = clampIndex(currentIndex - 1);
                saveSettings();
                render();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                currentIndex = clampIndex(currentIndex + 1);
                saveSettings();
                render();
            }
        });

        // Êí≠ÊîæÊñáÊú¨
        playBtn.addEventListener('click', () => {
            const text = mode === 'single' ? (data.sentences[currentIndex] || '') : data.sentences.join('. ');
            speakText(text);
        });

        // ÊóßÁöÑ‚ÄúÁÆÄÊòìÂΩïÈü≥ÊåâÈíÆ‚ÄùÁõëÂê¨Âô®Â∑≤ÁßªÈô§ÔºåÈÅøÂÖç‰∏éÁªü‰∏ÄÊçïËé∑Èò∂ÊÆµÁªëÂÆöÂÜ≤Á™Å„ÄÇ

        // ÈáçÁΩÆÔºà‰ªÖÈáçÁΩÆÂΩïÈü≥/ÂõûÊîæ‰∏éËØÑÂàÜÁä∂ÊÄÅÔºå‰∏çÂΩ±ÂìçÊ®°Âºè/Èü≥Ê†á/Ëã±ÁæéÈü≥Á≠âËÆæÁΩÆÔºâ
        resetBtn.addEventListener('click', () => {
            try {
                if (typeof stopSpeaking === 'function') stopSpeaking();
                if (typeof stopPlayback === 'function') stopPlayback();
                if (recordBtn && recordBtn.classList && recordBtn.classList.contains('recording')) {
                    try { if (typeof stopRecording === 'function') stopRecording(true); } catch {}
                }
                if (recordBtn && recordBtn.classList) { recordBtn.classList.remove('recording'); recordBtn.textContent = 'üéô ÂºÄÂßãÂΩïÈü≥'; }
                if (recordedAudioUrl) { try { URL.revokeObjectURL(recordedAudioUrl); } catch {} }
                recordedAudioUrl = null;
                lastRecordedBlob = null;
                if (listenBtn) listenBtn.disabled = true;
                try { if (typeof clearRecordingHighlight === 'function') clearRecordingHighlight(); } catch {}
                try { if (typeof clearAccuracyHighlights === 'function') clearAccuracyHighlights(); } catch {}
                try {
                    __lastScoring = null;
                    const scoreSection = document.getElementById('scoreSection');
                    const scoreSummary = document.getElementById('scoreSummary');
                    const scoreDetails = document.getElementById('scoreDetails');
                    if (scoreSummary) scoreSummary.textContent = '';
                    if (scoreDetails) scoreDetails.textContent = '';
                    if (scoreSection) scoreSection.hidden = true;
                } catch {}
            } catch {}
        });
        /* DUPLICATE BLOCK REMOVED - start
        // Token renderer (word + IPA) with click-to-speak
        function renderToken(word) {
            const token = document.createElement('div');
            token.className = 'token';
            
            const wordEl = document.createElement('div');
            wordEl.className = 'word';
            wordEl.textContent = word;
            
            const ipaEl = document.createElement('div');
            ipaEl.className = 'ipa';
            const ipaText = getPhonetic(word);
            ipaEl.textContent = ipaText;
            ipaEl.dataset.empty = ipaText ? 'false' : 'true';
            ipaEl.style.display = showPhonetic ? 'block' : 'none';
            
            token.appendChild(wordEl);
            token.appendChild(ipaEl);
            
            // Click actions
            token.addEventListener('click', () => speakWord(word));
            ipaEl.addEventListener('click', (e) => {
                e.stopPropagation();
                speakWord(word);
            });
            
            return token;
        }

        function updateProgress() {
            if (mode === 'single') {
                const progress = ((currentIndex + 1) / data.sentences.length) * 100;
                progressBar.style.width = `${progress}%`;
            } else {
                progressBar.style.width = '100%';
            }
        }

        // Enhanced render function
        function render() {
            setEyeButton(togglePhoneticBtn, showPhonetic, 'Èü≥Ê†á');
            togglePhoneticBtn.classList.toggle('toggled', showPhonetic);
            updateProgress();

            if (mode === 'full') {
                singleSection.hidden = true;
                fullSection.hidden = false;
                fullSection.innerHTML = '';
                
                data.sentences.forEach(sentence => {
                    const card = document.createElement('div');
                    card.className = 'sentence-card';
                    
                    const wrapper = document.createElement('div');
                    wrapper.className = 'tokens';
                    
                    tokenize(sentence).forEach(word => {
                        wrapper.appendChild(renderToken(word));
                    });
                    
                    card.appendChild(wrapper);
                    fullSection.appendChild(card);
                });
            } else {
                fullSection.hidden = true;
                singleSection.hidden = false;
                pager.textContent = `${currentIndex + 1} / ${data.sentences.length}`;
                
                singleTokens.innerHTML = '';
                tokenize(data.sentences[currentIndex]).forEach(word => {
                    singleTokens.appendChild(renderToken(word));
                });
            }
        }
                });
            }
            // if recording, re-bind highlight to the new DOM
            if (recordBtn.classList.contains('recording')) {
                prepareRecordingHighlight();
            }
        }

        // ÁÇπÂáªÂàáÊç¢Ê®°Âºè
        modeSeg.addEventListener('click', (e) => {
            const item = e.target.closest('.item');
            if (!item) return;
            mode = item.dataset.mode === 'single' ? 'single' : 'full';
            applyUIState();
            saveSettings();
            render();
        });

        // ÂàáÊç¢Âè£Èü≥
        accentSeg.addEventListener('click', (e) => {
            const item = e.target.closest('.item');
            if (!item) return;
            const acc = item.dataset.accent;
            if (acc === 'us' || acc === 'uk') accent = acc;
            applyUIState();
            saveSettings();
            render();
        });

        // ÂàáÊç¢ËØ≠ÈÄü
        speedSeg.addEventListener('click', (e) => {
            const item = e.target.closest('.sitem');
            if (!item) return;
            const r = parseFloat(item.dataset.rate);
            if (!Number.isNaN(r)) rate = r;
            applyUIState();
            saveSettings();
        });

        // ÂàáÊç¢Èü≥Ê†áÊòæÁ§∫
        togglePhoneticBtn.addEventListener('click', () => {
            showPhonetic = !showPhonetic;
            applyUIState();
            saveSettings();
            render();
        });

        // Âè•Â≠êÁøªÈ°µÔºàÂçïÂè•Ê®°ÂºèÔºâ
        function clampIndex(i){
            return Math.max(0, Math.min(i, data.sentences.length - 1));
        }
        prevBtn && prevBtn.addEventListener('click', () => {
            if (mode !== 'single') return;
            currentIndex = clampIndex(currentIndex - 1);
            saveSettings();
            render();
        });
        nextBtn && nextBtn.addEventListener('click', () => {
            if (mode !== 'single') return;
            currentIndex = clampIndex(currentIndex + 1);
            saveSettings();
            render();
        });

        // ÈîÆÁõòÂØºËà™
        document.addEventListener('keydown', (e) => {
            if (mode !== 'single') return;
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                currentIndex = clampIndex(currentIndex - 1);
                saveSettings();
                render();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                currentIndex = clampIndex(currentIndex + 1);
                saveSettings();
                render();
            }
        });

        // Êí≠ÊîæÊñáÊú¨
        playBtn.addEventListener('click', () => {
            const text = mode === 'single' ? (data.sentences[currentIndex] || '') : data.sentences.join('. ');
            speakText(text);
        });

        // ÊóßÁöÑ‚ÄúÁÆÄÊòìÂΩïÈü≥ÊåâÈíÆ‚ÄùÁõëÂê¨Âô®Â∑≤ÁßªÈô§ÔºåÈÅøÂÖç‰∏éÁªü‰∏ÄÊçïËé∑Èò∂ÊÆµÁªëÂÆöÂÜ≤Á™Å„ÄÇ

        // ÈáçÁΩÆÔºà‰ªÖÈáçÁΩÆÂΩïÈü≥/ÂõûÊîæ‰∏éËØÑÂàÜÁä∂ÊÄÅÔºå‰∏çÂΩ±ÂìçÊ®°Âºè/Èü≥Ê†á/Ëã±ÁæéÈü≥Á≠âËÆæÁΩÆÔºâ
        resetBtn.addEventListener('click', () => {
            try {
                if (typeof stopSpeaking === 'function') stopSpeaking();
                if (typeof stopPlayback === 'function') stopPlayback();
                if (recordBtn && recordBtn.classList && recordBtn.classList.contains('recording')) {
                    try { if (typeof stopRecording === 'function') stopRecording(true); } catch {}
                }
                if (recordBtn && recordBtn.classList) { recordBtn.classList.remove('recording'); recordBtn.textContent = 'üéô ÂºÄÂßãÂΩïÈü≥'; }
                if (recordedAudioUrl) { try { URL.revokeObjectURL(recordedAudioUrl); } catch {} }
                recordedAudioUrl = null;
                lastRecordedBlob = null;
                if (listenBtn) listenBtn.disabled = true;
                try { if (typeof clearRecordingHighlight === 'function') clearRecordingHighlight(); } catch {}
                try { if (typeof clearAccuracyHighlights === 'function') clearAccuracyHighlights(); } catch {}
                try {
                    __lastScoring = null;
                    const scoreSection = document.getElementById('scoreSection');
                    const scoreSummary = document.getElementById('scoreSummary');
                    const scoreDetails = document.getElementById('scoreDetails');
                    if (scoreSummary) scoreSummary.textContent = '';
                    if (scoreDetails) scoreDetails.textContent = '';
                    if (scoreSection) scoreSection.hidden = true;
                } catch {}
            } catch {}
        });
        /* DUPLICATE BLOCK REMOVED - mid end */
        // ËØ≠Èü≥ÂêàÊàê‰∏éÂΩïÈü≥/ÂõûÊîæÊéßÂà∂Ôºà‰∫íÊñ• + ÊåâÈíÆÁä∂ÊÄÅÔºâ
        let __voices = [];
        function preloadVoices() {
            try {
                __voices = window.speechSynthesis ? window.speechSynthesis.getVoices() : [];
                if (window.speechSynthesis && (!__voices || __voices.length === 0)) {
                    window.speechSynthesis.addEventListener('voiceschanged', () => {
                        __voices = window.speechSynthesis.getVoices();
                    }, { once: true });
                }
            } catch {}
        }
        preloadVoices();
        function pickVoiceByAccent(acc) {
            if (!__voices || __voices.length === 0) return null;
            const prefer = acc === 'uk' ? ['en-GB', 'UK', 'British'] : ['en-US', 'US', 'American'];
            // Áî®Êà∑ÊÄßÂà´ÂÅèÂ•ΩÔºàÂü∫‰∫éÂêçÁß∞ÂåÖÂê´ Female/Male ÊàñÂ∏∏ËßÅ TTS ÂêçÔºâ
            const prefName = acc === 'uk' ? (voiceChoiceUK || 'UK-Female') : (voiceChoiceUS || 'US-Female');
            const wantMale = /Male/i.test(prefName);
            const wantFemale = /Female/i.test(prefName);
            // ÂÖàÊåâÂè£Èü≥+ÊÄßÂà´ÂåπÈÖç
            let match = __voices.find(v => {
                const okAccent = prefer.some(k => (v.lang && v.lang.includes(k)) || (v.name && v.name.includes(k)));
                if (!okAccent) return false;
                const nm = (v.name || '') + ' ' + (v.lang || '');
                if (wantMale) return /male|guy|david|george|ben|dan/i.test(nm);
                if (wantFemale) return /female|susan|sara|lisa|emma|amy|sophie|victoria|kate|eva/i.test(nm);
                return true;
            });
            // ÂõûÈÄÄÔºö‰ªÖÊåâÂè£Èü≥
            if (!match) match = __voices.find(v => prefer.some(k => (v.lang && v.lang.includes(k)) || (v.name && v.name.includes(k))));
            // ÂõûÈÄÄÔºö‰ªªÊÑèËã±Êñá
            return match || __voices.find(v => (v.lang || '').startsWith('en')) || __voices[0] || null;
        }

        // Áä∂ÊÄÅ‰∏éËµÑÊ∫ê
        let isSpeaking = false;
        let isReplaying = false;
        let playbackAudio = null;
        let recordedAudioUrl = null;
        let mediaStream = null;
let mediaRecorder = null;
let recordedChunks = [];
// ÂΩïÈü≥‰∏éÂÆûÊó∂ËØ≠Èü≥Èó®ÊéßÔºàVADÔºâÁä∂ÊÄÅ
let __recorderMime = null;
let __vadAC = null, __vadAnalyser = null, __vadSource = null, __vadTimer = null;
window.__vadSpeaking = undefined;

function pickRecorderMime(){
    try{
        if (typeof MediaRecorder === 'undefined') return null;
        const candidates = [
            'audio/webm;codecs=opus',
            'audio/ogg;codecs=opus',
            'audio/webm',
            'audio/ogg',
            'audio/mp4'
        ];
        for (const t of candidates){
            try { if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t; } catch {}
        }
    }catch{}
    return null;
}
function startVAD(stream){
    try{
        const AC = window.AudioContext || window.webkitAudioContext;
        __vadAC = new AC({ latencyHint: 'interactive' });
        __vadSource = __vadAC.createMediaStreamSource(stream);
        __vadAnalyser = __vadAC.createAnalyser();
        __vadAnalyser.fftSize = 1024;
        __vadAnalyser.smoothingTimeConstant = 0.8;
        __vadSource.connect(__vadAnalyser);
        const data = new Uint8Array(__vadAnalyser.fftSize);
        let lastSpeakTs = 0;
        window.__vadSpeaking = false;
        try { if (window.__blueTracker) window.__blueTracker.setSpeaking(false); } catch {}
        if (__vadTimer) { try { clearInterval(__vadTimer); } catch{} }
        __vadTimer = setInterval(()=>{
            try{
                if (!__vadAnalyser) return;
                __vadAnalyser.getByteTimeDomainData(data);
                let sum=0;
                for(let i=0;i<data.length;i++){
                    const v = (data[i]-128)/128; // [-1,1]
                    sum += v*v;
                }
                const rms = Math.sqrt(sum/data.length);
                const now = Date.now();
                const speaking = rms > 0.03; // ÁªèÈ™åÈòàÂÄºÔºåÈò≤ÈùôÈªòÊé®Ëøõ
                if (speaking) lastSpeakTs = now;
                // Âä†ÂÖ•‰øùÊåÅÊó∂Èó¥ÔºåÈÅøÂÖçÂç°È°ø
                window.__vadSpeaking = (now - lastSpeakTs) < 250;
                try { if (window.__blueTracker) window.__blueTracker.setSpeaking(window.__vadSpeaking); } catch {}
            }catch{}
        }, 50);
    }catch(e){ console.warn('VAD init failed', e); }
}
function stopVAD(){
    try{
        if (__vadTimer){ try { clearInterval(__vadTimer); } catch{} __vadTimer = null; }
        window.__vadSpeaking = false;
        try { if (window.__blueTracker) window.__blueTracker.setSpeaking(false); } catch {}
        if (__vadSource){ try{ __vadSource.disconnect(); } catch{} __vadSource = null; }
        if (__vadAnalyser){ try{ __vadAnalyser.disconnect(); } catch{} __vadAnalyser = null; }
        if (__vadAC){ try{ __vadAC.close(); } catch{} __vadAC = null; }
    }catch{}
}
        let lastRecordedBlob = null;
        let __lastScoring = null; // { feats, wordCount, tips, advProxy, advReal, werInfo }
        let __scoreMode = 'basic'; // 'basic' | 'proxy' | 'real'

        function updatePlayBtn(playing){
            playBtn.classList.toggle('playing', playing);
            playBtn.textContent = playing ? '‚èπ Ê≠£Âú®ÊúóËØª' : '‚ñ∂ Êí≠Êîæ';
        }
        function updateListenBtn(playing){
            listenBtn.classList.toggle('playing', playing);
            listenBtn.textContent = playing ? '‚èπ Ê≠£Âú®ÂõûÊîæ' : 'üëÇ Âê¨Âê¨ÂõûÊîæ';
        }
        function stopSpeaking(){
            if (window.speechSynthesis) { try { window.speechSynthesis.cancel(); } catch{} }
            if (isSpeaking){ isSpeaking = false; updatePlayBtn(false); }
        }
        function stopPlayback(){
            if (playbackAudio){ try { playbackAudio.pause(); playbackAudio.currentTime = 0; } catch{} }
            if (isReplaying){ isReplaying = false; updateListenBtn(false); }
        }
        async function startRecording(){
                    stopSpeaking();
                    stopPlayback();
                    window.__asrCoverage = null;
                    try { if (window.__blueClearTimer) { clearTimeout(window.__blueClearTimer); window.__blueClearTimer = null; } } catch {}
                    try {
                        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new Error('getUserMedia not supported');
                        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        // ÂêØÂä®ÂÆûÊó∂ËØ≠Èü≥Èó®Êéß
                        startVAD(mediaStream);
                        recordedChunks = [];
                        __recorderMime = pickRecorderMime();
                        mediaRecorder = __recorderMime ? new MediaRecorder(mediaStream, { mimeType: __recorderMime }) : new MediaRecorder(mediaStream);
                        mediaRecorder.ondataavailable = (e)=>{ if (e.data && e.data.size) recordedChunks.push(e.data); };
                        mediaRecorder.onstop = ()=>{
                            try {
                                if (recordedChunks.length){
                                    const blobType = __recorderMime || 'audio/webm';
                                    const blob = new Blob(recordedChunks, { type: blobType });
                                    lastRecordedBlob = blob;
                                    if (recordedAudioUrl) { try { URL.revokeObjectURL(recordedAudioUrl); } catch{} }
                                    recordedAudioUrl = URL.createObjectURL(blob);
                                    if (listenBtn) listenBtn.disabled = false;
                                    try { window.__asrCoverage = __computeCoverageFromRecHL(); } catch {}
                                    if (typeof scoringEnabled === 'undefined' || scoringEnabled) {
                                        if (!window.__scoringBusy) computeAndRenderScore(blob);
                                    }
                                }
                            } catch (e) { console.warn('onstop scoring error', e); }
                            if (mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream = null; }
                            stopVAD();
                        };
                        mediaRecorder.start();
                        recordBtn.classList.add('recording');
                        recordBtn.textContent = '‚ñ† ÂÅúÊ≠¢ÂΩïÈü≥';
                        if (listenBtn) listenBtn.disabled = true;
                        prepareRecordingHighlight && prepareRecordingHighlight();
                    } catch (err) {
                        recordBtn.classList.add('recording');
                        recordBtn.textContent = '‚ñ† ÂÅúÊ≠¢ÂΩïÈü≥';
                        try { prepareRecordingHighlight && prepareRecordingHighlight(); } catch {}
                    }
                }
        function stopRecording(preserve=true){
            try {
                if (mediaRecorder && mediaRecorder.state !== 'inactive'){ mediaRecorder.stop(); }
                if (mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream = null; }
            } catch {}
            try { stopVAD(); } catch {}
            recordBtn.classList.remove('recording');
            recordBtn.textContent = 'üéô ÂºÄÂßãÂΩïÈü≥';
            // ÂÅúÊ≠¢ËØÜÂà´/ËÆ°Êó∂‰ΩÜ‰øùÁïôËìùËâ≤ÔºåËã•‰∏ç‰øùÁïôÂàôÁ´ãÂç≥Ê∏ÖËìù
            try { stopRecHighlightEnginesPreserve && stopRecHighlightEnginesPreserve(); } catch {}
            if (!preserve) {
                try { clearRecordingHighlight && clearRecordingHighlight(); } catch {}
            } else {
                try { scheduleBlueClear && scheduleBlueClear(5000, true); } catch {}
            }
            if (listenBtn) listenBtn.disabled = !recordedAudioUrl;
            // Â¶ÇÊûúÊ≤°ÊúâÂΩïÂà∞Èü≥È¢ëÔºåÊòæÁ§∫ËØÑÂàÜÂå∫ÊèêÁ§∫
            try {
                const hasAudio = !!(recordedAudioUrl || (recordedChunks && recordedChunks.length));
                if (!hasAudio) {
                    const scoreSection = document.getElementById('scoreSection');
                    const scoreSummary = document.getElementById('scoreSummary');
                    const scoreDetails = document.getElementById('scoreDetails');
                    if (scoreSection) scoreSection.hidden = false;
                    const scoringOff = (typeof scoringEnabled !== 'undefined' && !scoringEnabled);
                    if (scoreSummary) {
                        scoreSummary.textContent = scoringOff ? 'ËØÑÂàÜÂäüËÉΩÂ∑≤ÂÖ≥Èó≠ÔºåÂ¶ÇÈúÄËØ∑ÊâìÂºÄÈ°∂ÈÉ®ËØÑÂàÜÊåâÈíÆ' : 'ÊöÇÊó†ÂΩïÈü≥ÔºåÊó†Ê≥ïËØÑÂàÜ';
                        scoreSummary.style.color = scoringOff ? '#C4C4C4' : '';
                    }
                    if (scoreDetails) scoreDetails.textContent = scoringOff ? '' : 'ËØ∑ÂÖÅËÆ∏È∫¶ÂÖãÈ£éÊùÉÈôêÂπ∂ÈáçËØï„ÄÇ';
                }
            } catch {}
        }

        function speakText(txt) {
            if (!txt || !window.speechSynthesis || typeof SpeechSynthesisUtterance === 'undefined') return;
            const u = new SpeechSynthesisUtterance(txt);
            const v = pickVoiceByAccent(accent);
            if (v) u.voice = v;
            u.rate = rate || 1;
            u.onstart = () => { isSpeaking = true; updatePlayBtn(true); };
            const finalize = () => { isSpeaking = false; updatePlayBtn(false); };
            u.onend = finalize;
            u.onerror = finalize;
            try { window.speechSynthesis.cancel(); } catch {}
            window.speechSynthesis.speak(u);
        }
        function speakWord(word) { speakText(word); }

        // Áªü‰∏ÄÁªëÂÆöÔºàÊçïËé∑Èò∂ÊÆµÊã¶Êà™ÔºåÈÅøÂÖçÈáçÂ§çÁªëÂÆöÂíåÊóßÁõëÂê¨ÂÜ≤Á™ÅÔºâ
        if (!window.__boundControls) {
            // Êí≠ÊîæÊåâÈíÆÔºöÂàáÊç¢Êí≠Êîæ/ÂÅúÊ≠¢Ôºå‰∏î‰∏éÂΩïÈü≥„ÄÅÂõûÊîæ‰∫íÊñ•
            playBtn.addEventListener('click', (e) => {
                e.preventDefault(); e.stopImmediatePropagation();
                const text = mode === 'single' ? (data.sentences[currentIndex] || '') : data.sentences.join('. ');
                if (isSpeaking) { stopSpeaking(); return; }
                // ‰∫íÊñ•ÔºöÂÅúÊ≠¢ÂΩïÈü≥‰∏éÂõûÊîæ
                if (recordBtn.classList.contains('recording')) stopRecording(true);
                stopPlayback();
                speakText(text);
            }, { capture: true });

            // ÂΩïÈü≥ÊåâÈíÆÔºöÂàáÊç¢ÂΩïÈü≥Ôºå‰∏î‰∏éÊí≠Êîæ„ÄÅÂõûÊîæ‰∫íÊñ•ÔºõÂÅúÊ≠¢Êó∂‰øùÁïôÁâáÊÆµ
            recordBtn.addEventListener('click', (e) => {
                e.preventDefault(); e.stopImmediatePropagation();
                if (recordBtn.classList.contains('recording')) {
                    stopRecording(true);
                } else {
                    stopSpeaking();
                    stopPlayback();
                    startRecording();
                }
            }, { capture: true });

            // ÂõûÊîæÊåâÈíÆÔºöÂõûÊîæÂ∑≤ÂΩïÈü≥Ôºõ‰∏éÊí≠Êîæ„ÄÅÂΩïÈü≥‰∫íÊñ•ÔºõÂÜçÊ¨°ÁÇπÂáªÂàôÂÅúÊ≠¢ÂõûÊîæ
            listenBtn && listenBtn.addEventListener('click', (e) => {
                e.preventDefault(); e.stopImmediatePropagation();
                if (listenBtn.disabled) return;
                if (isReplaying) { stopPlayback(); return; }
                stopSpeaking();
                if (recordBtn.classList.contains('recording')) stopRecording(true);
                if (!recordedAudioUrl) return;
                try {
                    if (playbackAudio) { try { playbackAudio.pause(); } catch{} }
                    playbackAudio = new Audio(recordedAudioUrl);
                    playbackAudio.onplaying = () => { isReplaying = true; updateListenBtn(true); };
                    const done = () => { stopPlayback(); };
                    playbackAudio.onended = done;
                    playbackAudio.onpause = done;
                    playbackAudio.onerror = done;
                    playbackAudio.play();
                } catch {
                    // Â¶ÇÊûúÂõûÊîæÂ§±Ë¥•ÔºåÊÅ¢Â§çÊåâÈíÆ
                    stopPlayback();
                }
            }, { capture: true });

            window.__boundControls = true;
        }
        
        // ===== ËØÑÂàÜÂÆûÁé∞Ôºö‰∏ç‰æùËµñÂ§ßÊ®°ÂûãÔºàÁ∫ØÂâçÁ´ØÔºâ =====
        // Â∑•ÂÖ∑ÂáΩÊï∞
        function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
        function mean(arr){ if(!arr.length) return 0; return arr.reduce((s,x)=>s+x,0)/arr.length; }
        function std(arr){ if(arr.length<2) return 0; const m=mean(arr); return Math.sqrt(mean(arr.map(x=>(x-m)*(x-m)))); }
        function median(arr){ if(!arr.length) return 0; const s=[...arr].sort((a,b)=>a-b); const mid=Math.floor(s.length/2); return (s.length%2)?s[mid]:(s[mid-1]+s[mid])/2; }
        function percentile(arr, p){ if(!arr.length) return 0; const s=[...arr].sort((a,b)=>a-b); const idx=Math.max(0,Math.min(s.length-1,Math.floor(s.length*p/100))); return s[idx]; }
        function preEmphasis(x, a=0.97){ const y=new Float32Array(x.length); y[0]=x[0]; for(let i=1;i<x.length;i++){ y[i]=x[i]-a*x[i-1]; } return Array.from(y); }
        function frame(arr, size, hop){ const out=[]; for(let i=0;i+size<=arr.length;i+=hop){ out.push(arr.slice(i,i+size)); } return out; }
        function normalize(arr){
    // ÈÅøÂÖçÂú®Ë∂ÖÈïøÊï∞ÁªÑ‰∏ä‰ΩøÁî®Êâ©Â±ïËøêÁÆóÁ¨¶ÔºåÈò≤Ê≠¢‚ÄúMaximum call stack size exceeded‚Äù
    const n = arr.length | 0;
    let mx = 0;
    for (let i = 0; i < n; i++) {
        const v = arr[i];
        const ab = v < 0 ? -v : v;
        if (ab > mx) mx = ab;
    }
    const denom = Math.max(1e-12, mx);
    const g = 1 / denom;
    if (ArrayBuffer.isView(arr)) {
        const out = new Float32Array(n);
        for (let i = 0; i < n; i++) out[i] = arr[i] * g;
        return out;
    } else {
        const out = new Array(n);
        for (let i = 0; i < n; i++) out[i] = arr[i] * g;
        return out;
    }
}
        // FAC helpers
        function clamp01(x){ return Math.max(0, Math.min(1, x)); }
        function lin(x, lo, hi){ return clamp01((x - lo) / (hi - lo)); }
        function sig(x, c=0, k=1){ return 1/(1+Math.exp(-k*(x-c))); }
        function resampleLinear(input, fromSr, toSr){ if(fromSr===toSr) return input.slice(); const ratio = toSr/fromSr; const n = Math.floor(input.length*ratio); const out = new Float32Array(n); for(let i=0;i<n;i++){ const src = i/ratio; const j = Math.floor(src); const t = src - j; const a = input[j] || 0; const b = input[j+1] || 0; out[i] = a*(1-t) + b*t; } return Array.from(out); }
        function zeroCrossRate(arr){ let c=0; for(let i=1;i<arr.length;i++){ if((arr[i-1] <= 0 && arr[i] > 0) || (arr[i-1] >= 0 && arr[i] < 0)) c++; } return c/arr.length; }
        function consecutiveRuns(bools){ let maxRun=0,cur=0; for(const b of bools){ if(b){ cur++; maxRun=Math.max(maxRun,cur);} else { cur=0;} } return maxRun; }
        // ACF Âü∫Á°Ä F0 ‰º∞ËÆ°ÔºàÁÆÄÂçïÁ®≥ÂÅ•ÁâàÔºâ
        function estimateF0ACF(frame, sr, fmin=70, fmax=400){
            const n=frame.length; if(n<8) return { f0: 0, r: 0 };
            const lo = Math.max(1, Math.floor(sr/fmax));
            const hi = Math.min(n-2, Math.floor(sr/fmin));
            let bestLag=0, bestR=-1;
            const m = mean(frame);
            const x = frame.map(v=>v-m);
            for(let tau=lo; tau<=hi; tau++){
                let num=0, denom2=0, denom3=0;
                for(let i=0;i<n-tau;i++){ const a=x[i], b=x[i+tau]; num += a*b; denom2 += a*a; denom3 += b*b; }
                const r = num / Math.sqrt((denom2||1e-9)*(denom3||1e-9));
                if(r>bestR){ bestR=r; bestLag=tau; }
            }
            const f0 = (bestLag>0) ? (sr/bestLag) : 0;
            const ok = (f0>=fmin && f0<=fmax) ? f0 : 0;
            return { f0: ok, r: clamp01(bestR) };
        }
        async function decodeToPCM(blob){
            const AC = window.AudioContext || window.webkitAudioContext;
            const ac = new AC({ sampleRate: 44100 });
            const buf = await blob.arrayBuffer();
            let audioBuf = null;
            try {
                const maybePromise = ac.decodeAudioData(buf);
                if (maybePromise && typeof maybePromise.then === 'function') {
                    // Promise È£éÊ†ºÔºàChromium Á≠âÔºâ
                    audioBuf = await maybePromise;
                } else {
                    // Callback È£éÊ†ºÔºàÈÉ®ÂàÜ Firefox ÁâàÊú¨Á≠âÔºâ
                    audioBuf = await new Promise((resolve, reject) => ac.decodeAudioData(buf, resolve, reject));
                }
            } catch (e) {
                try {
                    // ÂÜçÊ¨°Â∞ùËØï Callback È£éÊ†ºÔºåÂÖºÂÆπÊüê‰∫õ‰ªÖÊîØÊåÅÂõûË∞ÉÁöÑÂÆûÁé∞
                    audioBuf = await new Promise((resolve, reject) => ac.decodeAudioData(buf, resolve, reject));
                } catch (e2) {
                    console.warn('decodeAudioData failed', e, e2);
                    try { ac.close(); } catch {}
                    // ÂÖúÂ∫ïÔºöËøîÂõûÁ©∫ PCMÔºåÈÅøÂÖçÂêéÁª≠ÊµÅÁ®ãÂ¥©Ê∫É
                    return { pcm: [], sr: 16000 };
                }
            }
            const ch0raw = (audioBuf.numberOfChannels > 0) ? audioBuf.getChannelData(0) : new Float32Array(audioBuf.length || 0);
            const ch0 = preEmphasis(ch0raw, 0.97);
            const sr = audioBuf.sampleRate || 44100;
            try { ac.close(); } catch {}
            return { pcm: Array.from(ch0), sr };
        }
        function computeDurationsFromTokens(){
            // ‰º∞ËÆ°ÁõÆÊ†áËØçÊó∂ÈïøÔºöÊ†πÊçÆÂ≠óÁ¨¶Êï∞‰∏éËØ≠ÈÄüÁ≤óÁï•ÂàÜÈÖçÔºà‰ªÖÁî®‰∫éÊó† ASR Á≤óÁï•ÂØπÈΩêÔºâ
            const container = (mode === 'single') ? (singleTokens || document) : (fullSection || document);
            const tokens = Array.from(container.querySelectorAll('.token .word'));
            const words = tokens.map(el => (el.textContent||'').trim()).filter(Boolean);
            const chars = words.map(w=>w.replace(/[^A-Za-z']/g,'').length || 1);
            const totalChars = chars.reduce((s,x)=>s+x,0);
            // ÊåâÊ®°ÂºèÂå∫ÂàÜÈòÖËØªÁõÆÊ†áÔºöÂçïÂè•Êõ¥Âø´(‚âà2.0 ËØç/Áßí)ÔºåÂÖ®ÁØá‚âà1.3 ËØç/ÁßíÔºõÂπ∂Âå∫ÂàÜÊúÄÂ∞èÊó∂ÈïøÂ§πÁ¥ß
            const readWpsTarget = (mode === 'single') ? 2.0 : 1.3;
            const baseTime = words.length * (1.0 / (readWpsTarget * (rate||1)));
            const minClamp = (mode === 'single') ? 0.5 : 1.8;
            const totalTime = clamp(baseTime, minClamp, 60);
            const per = chars.map(c => totalTime * (c/Math.max(1,totalChars)));
            return { words, perWordSec: per };
        }
        function vadSegments(pcm, sr){
            // ÁÆÄÂçïËÉΩÈáèÈòàÂÄº+ZCR VAD
            const win = Math.floor(0.03*sr), hop = Math.floor(0.015*sr);
            const frames = frame(pcm, win, hop);
            const energies = frames.map(fr=>mean(fr.map(x=>x*x)));
            const zcrs = frames.map(fr=>zeroCrossRate(fr));
            const eMed = median(energies);
            const zThr = 0.25;
            const voiced = frames.map((fr,i)=> (energies[i] > eMed*3 && zcrs[i] < 0.35) || (energies[i] > eMed*0.6 && zcrs[i] < zThr));
            // ÂêàÂπ∂‰∏∫Êó∂Èó¥ÊÆµ
            const segs=[]; let cur=null;
            for(let i=0;i<voiced.length;i++){
                const start = i*hop; const end = start+win;
                if(voiced[i]){
                    if(!cur) cur = { start, end };
                    else cur.end = end;
                }else{
                    if(cur){ segs.push(cur); cur=null; }
                }
            }
            if(cur) segs.push(cur);
            // ËøáÁü≠ÊÆµËêΩ‰∏¢ÂºÉ
            const minLen = Math.floor(0.08*sr);
            return segs.filter(s=> (s.end - s.start) >= minLen);
        }
        function computeFeatures(pcm, sr){
            const x = normalize(pcm);
            // VAD ÂàáÂàÜ
            const segs = vadSegments(x, sr);
            const voicedLen = segs.reduce((s,g)=>s+(g.end-g.start),0);
            const voicedSec = voicedLen/sr;
            const totalSec = x.length/sr;
            const gapsSec = Math.max(0, totalSec - voicedSec);
            // ËÆ°ÁÆó RMS ‰∏é F0
            const win = Math.floor(0.04*sr), hop = Math.floor(0.02*sr);
            const frames = frame(x, win, hop);
            // ÈÅøÂÖçÂØπË∂ÖÈïøÂ∏ßÊï∞ÁªÑ‰ΩøÁî® .map ÁöÑÂõûË∞ÉÂºÄÈîÄÂíåÊΩúÂú®ÁöÑË∞ÉÁî®Ê†àÈóÆÈ¢ò
            const rmss = new Array(frames.length);
            for (let i=0;i<frames.length;i++){
                const fr = frames[i];
                let acc = 0; for (let j=0;j<fr.length;j++){ const v = fr[j]; acc += v*v; }
                rmss[i] = Math.sqrt(acc/Math.max(1,fr.length));
            }
            const f0s = new Array(frames.length);
            const f0rs = new Array(frames.length);
            for (let i=0;i<frames.length;i++){
                const fr = estimateF0ACF(frames[i], sr, 80, 350);
                f0s[i] = fr.f0 || 0;
                f0rs[i] = fr.r || 0;
            }
            const f0Valid = f0s.filter(f=>f>50 && f<400);
            const f0PctValid = f0Valid.length/Math.max(1,f0s.length);
            const f0Median = median(f0Valid);
            const f0RMean = mean(f0rs);
            const rmsMean = mean(rmss);
            const rmsStd = std(rmss);
            // Long pause count (gaps >= 2.0s) between voiced segments, and track max pause
            let longPauseCount = 0;
            let maxPauseSec = 0;
            for (let i=1;i<segs.length;i++){
                const gapSamp = segs[i].start - segs[i-1].end;
                const gapSec = gapSamp/ sr;
                if (gapSec >= 2.0) longPauseCount++;
                if (gapSec > maxPauseSec) maxPauseSec = gapSec;
            }
            // Max voiced segment duration (proxy for per-word duration upper bound)
            let maxVoicedSegSec = 0;
            for (let i=0;i<segs.length;i++){
                const dur = (segs[i].end - segs[i].start)/sr;
                if (dur > maxVoicedSegSec) maxVoicedSegSec = dur;
            }
            return { voicedSec, gapsSec, rmsMean, rmsStd, f0Median, f0PctValid, totalSec, longPauseCount, maxPauseSec, maxVoicedSegSec };
        }
        function scoreFromFeatures(features){
            // Ê†πÊçÆ‚ÄúÁ®≥ÂÆöÊÄß„ÄÅËøûË¥ØÊÄß„ÄÅÈü≥Èáè„ÄÅÈü≥È´òËåÉÂõ¥‚ÄùÁªôÂá∫ 0-100 ÂàÜ
            const { voicedSec, gapsSec, rmsMean, rmsStd, f0Median, f0PctValid } = features;
            // Á®≥ÂÆöÊÄßÔºöÈü≥ÈáèÊñπÂ∑ÆÂ∞èÊõ¥Â•Ω
            const stability = clamp(1 - clamp(rmsStd/(rmsMean+1e-6), 0, 1), 0, 1);
            // ËøûË¥ØÊÄßÔºöÂÅúÈ°øÊØî‰æã‰∏çË¶ÅÂ§™È´ò
            const speechRatio = voicedSec/(voicedSec + gapsSec + 1e-6);
            const coherence = clamp((speechRatio - 0.4)/0.5, 0, 1); // 0.4-0.9 Á∫øÊÄß
            // Èü≥ÈáèÔºöÈÄÇ‰∏≠ÊúÄÂ•ΩÔºàÁõÆÊ†áÂùáÂÄº ~ -12dBFS => 0.25 RMSÔºâ
            const volTarget = 0.25, volScore = 1 - Math.abs(rmsMean - volTarget)/0.25; // ÂÅèÂ∑Æ 0.25 ËÆ∞Êª°Êâ£
            const volume = clamp(volScore, 0, 1);
            // Èü≥È´òÊ£ÄÊµãÊàêÂäüÁéá
            const pitch = clamp(f0PctValid, 0, 1);
            // Ê±áÊÄª
            const raw = 0.35*stability + 0.3*coherence + 0.2*volume + 0.15*pitch;
            return Math.round(clamp(raw,0,1)*100);
        }
        // FAC ËØÑÂàÜÂô®ÔºàÁ°ÆÂÆöÊÄßÔºâ
        function computeFACFromSignals(sig){
            const totalSec = Math.max(1e-6, Number(sig.totalSec||0));
            const voicedSec = Math.max(0, Number(sig.voicedSec||0));
            const gapsSec = Math.max(0, Number(sig.gapsSec||0));
            const speechRatio = voicedSec/(voicedSec + gapsSec + 1e-6);
            const longPauseCount = Math.max(0, Number(sig.longPauseCount||0));
            const pMax = (typeof sig.maxPauseSec === 'number') ? Number(sig.maxPauseSec) : 0;
            let pausePenalty = clamp01(1 - longPauseCount*0.18);
            if (pMax > 1.2) pausePenalty = clamp01(pausePenalty - Math.min(0.4, (pMax - 1.2) * 0.25));
            let rateScore = 0.7;
            if (typeof sig.rateWps === 'number' && isFinite(sig.rateWps)){
                // Êõ¥ÂÆΩÊùæÁöÑËØ≠ÈÄüÂÆπÂøçÂå∫Èó¥ÔºåÁõÆÊ†áÁ∫¶ 1.0 ËØç/Áßí
                rateScore = clamp01(1 - Math.abs(sig.rateWps - 1.0)/1.2);
            }
            // ËØ≠Èü≥Á®≥ÂÆöÂ∫¶ÔºàÁî®‰∫é‚ÄúÂç°Â£≥‚ÄùËøë‰ººÂà§Êñ≠Ôºâ
            const stb = clamp01(1 - (Number(sig.rmsStd||0))/((Number(sig.rmsMean||0))+1e-6));
            // Êî∂Á¥ß‚ÄúÁ°¨Êù°‰ª∂ÊµÅÂà©‚ÄùÔºöÊó†ÈáçÂ§ç„ÄÅÊó†ÈïøÂÅúÈ°ø„ÄÅÊúÄÂ§ßÂÅúÈ°ø<1.5s„ÄÅÈÄêËØçÊó∂Èïø<=1.2s
            const repeats = Math.max(0, Number(sig.repeatsCount||0));
            const maxWordSec = Number(sig.maxWordSec || sig.maxVoicedSegSec || 0);
            const meetsHardFluent = (repeats===0) && (longPauseCount===0) && (pMax>0 ? pMax < 1.5 : true) && (maxWordSec>0 ? (maxWordSec<=1.2) : true);
            const cov = (typeof sig.coveragePct === 'number' && isFinite(sig.coveragePct)) ? Number(sig.coveragePct) : null;
            let flu;
            if (meetsHardFluent && cov != null && cov >= 95){
                // ËØªÂæóÂÆåÊï¥Âπ∂Êª°Ë∂≥Êõ¥‰∏•Ê†ºÁ°¨Êù°‰ª∂
                flu = 1;
            } else {
                // ËΩØËØÑÂàÜÔºöËøûË¥ØÊÄß„ÄÅÂÅúÈ°ø„ÄÅËØ≠ÈÄü„ÄÅÈÄêËØçÊó∂Èïø‰∏éÈáçÂ§çÂÖ±ÂêåÂÜ≥ÂÆöÔºàÂ¢ûÂº∫ÊÉ©ÁΩöÔºâ
                const repeatScore = clamp01(1 - repeats*0.25);
                let wordDurScore = 1;
                if (maxWordSec>0) {
                    const over = Math.max(0, maxWordSec - 1.2);
                    wordDurScore = clamp01(1 - over/1.2);
                }
                const continuity = clamp01(lin(speechRatio,0.4,0.9));
                const soft = 0.30*continuity + 0.28*pausePenalty + 0.12*rateScore + 0.18*wordDurScore + 0.12*repeatScore;
                flu = clamp01(soft);
            }
            const stability = stb;
            const voicing = clamp01(Number(sig.f0PctValid||0));
            let acc;
            if (typeof sig.phScore === 'number' && isFinite(sig.phScore)) {
                acc = clamp01(sig.phScore / 100);
            } else {
                // ÊåâÁÖß‰øÆÂ§çÊñπÊ°à1045Ôºö‰ªÖÂü∫‰∫éÁ®≥ÂÆöÂ∫¶‰∏éÊàêÈü≥ÊØî‰æã‰º∞ËÆ°ÂáÜÁ°ÆÂ∫¶ÔºåÂπ∂Âä†ÂÖ•È´òË¥®ÈáèÈó®Êéß
                let accBase = 0.6 * stability + 0.4 * voicing;   // ‰∏éË¶ÜÁõñÁéáÊó†ÂÖ≥
                if (stability > 0.85 && voicing > 0.6) accBase = Math.max(accBase, 0.90);
                acc = clamp01(accBase);
            }
            // ÂÆåÊï¥Â∫¶Ôºö‰ª•‚ÄúËØªÂá∫ÂçïËØçÊØî‰æã‚Äù‰∏∫‰∏ªÔºõËã•ËØªÂÖ®‰∏îÊúÄÂ§ßÂÅúÈ°ø<2sÔºåÂàôÁªôÂà∞100ÂàÜ
            let comp;
            if (typeof sig.coveragePct === 'number' && isFinite(sig.coveragePct)) {
                comp = clamp01(Number(sig.coveragePct)/100);
                if (comp >= 0.999) {
                    const mx = (typeof sig.maxPauseSec === 'number') ? sig.maxPauseSec : null;
                    if (mx != null && mx >= 2.0) {
                        // ËØªÂÖ®‰ΩÜÂ≠òÂú®>=2sÂÅúÈ°øÔºå‰∏çËÆ∞Êª°ÂàÜÔºåËΩªÂæÆÊâ£ÂàÜ
                        comp = 0.98;
                    }
                }
            } else {
                comp = clamp01(lin(speechRatio, 0.5, 0.95));
            }
            const F = Math.round(flu*100);
            const A = Math.round(acc*100);
            const C = Math.round(comp*100);
            const overall = Math.round((F + A + C) / 3);
            return { overall, fluency: F, accuracy: A, completeness: C, weakPhonemes: Array.isArray(sig.weakPhonemes)?sig.weakPhonemes:[] };
        }

        // ===== ORT-Web + sherpa-onnx ÂèØÈÄâ GOP ÁÆ°Á∫øÔºàÂç†‰Ωç + Á∫ØÂâçÁ´ØÂÆûÁé∞Ôºâ =====
        let __ortReady = false; let __phonemeDict = null; let __phonemeDictLoading = null;
        async function ensureORT(){
            if (window.ort) { __ortReady = true; return true; }
            try{
                await new Promise((resolve, reject)=>{
                    const s=document.createElement('script');
                    s.src='https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js';
                    s.onload=resolve; s.onerror=reject; document.head.appendChild(s);
                });
                __ortReady = !!window.ort; return __ortReady;
            }catch{ return false; }
        }
        // ===== CTC ‰ºöËØù‰∏éÁúüÂÆû GOPÔºàÊúÄÂ∞èÂèØÁî®ÂÆûÁé∞ÔºåËã•Ê®°Âûã‰∏çÂèØÁî®Â∞ÜËá™Âä®ÂõûÈÄÄÔºâ =====
        const __CTC_MODEL_CANDIDATES = [
            // Êé®ËçêÔºöNeMo Ëã±Êñá CTCÔºàÂçïÊñá‰ª∂ int8 + tokensÔºâÔºå‰æø‰∫é ORT-Web ÂâçÁ´ØÊé®ÁêÜ
            { base: '../public/models/sherpa-onnx-nemo-parakeet_tdt_ctc_110m-en-36000-int8', model: 'model.int8.onnx', tokens: 'tokens.txt', type: 'nemo_ctc' },
            // È¢ÑÁïôÔºözipformer-ctcÔºàËã•‰Ω†ÊîæÂÖ•ÂØπÂ∫îÁõÆÂΩïÔºåÂèØË¢´ËØÜÂà´Ôºâ
            { base: '../public/models/sherpa-onnx-zipformer-ctc-en-2023-06-26', model: 'model.onnx', tokens: 'tokens.txt', type: 'zipformer_ctc' },
        ];
        const __ctcCtx = { ready: false, session: null, modelType: null, tokens: [], token2id: new Map(), blankId: 0, modelUrl: null, tokensUrl: null };
        function __guessProviders(){
            const prov = [];
            try{ if (ort && ort.env && ort.env.webgpu && typeof navigator !== 'undefined'){ prov.push('webgpu'); } }catch{}
            prov.push('wasm');
            return prov;
        }
        async function __fetchTextSafe(url){ try{ const r = await fetch(url); if(!r.ok) return null; return await r.text(); }catch{ return null; } }
        async function __ensureCTCArtifacts(){
            // Â∑≤ÁªèÂ∞±Áª™
            if (__ctcCtx.tokensUrl && __ctcCtx.modelUrl) return __ctcCtx;
            for (const c of __CTC_MODEL_CANDIDATES){
                const tUrl = `${c.base}/${c.tokens}`; const txt = await __fetchTextSafe(tUrl);
                if (!txt) continue;
                // Ëß£Êûê tokens.txt => ÊØèË°åÊ†ºÂºè: "token id"
                const lines = txt.split(/\r?\n/).filter(Boolean);
                const pairs = lines.map(l=>l.trim().split(/\s+/)).filter(a=>a.length>=2);
                const token2id = new Map(); let maxId = -1;
                for (const a of pairs){ const tok = a[0]; const id = parseInt(a[1],10); if (Number.isFinite(id)){ token2id.set(tok,id); if (id>maxId) maxId=id; } }
                if (maxId < 0) continue;
                const tokensById = Array.from({length:maxId+1}, (_,i)=>null);
                for (const [tok,id] of token2id){ tokensById[id]=tok; }
                // Â∏∏ËßÅ blank: <blk> / <blank> / [blank]
                let blankId = ([...token2id.entries()].find(([t])=>t==='<'+'blk'+'>' || t==='<'+'blank'+'>' || t==='[blank]')||[])[1];
                if (blankId==null) blankId = 0;
                __ctcCtx.tokens = tokensById; __ctcCtx.token2id = token2id; __ctcCtx.blankId = blankId; __ctcCtx.modelType = c.type;
                __ctcCtx.tokensUrl = tUrl; __ctcCtx.modelUrl = `${c.base}/${c.model}`;
                // ‰∏∫Ë¥™ÂøÉÂàÜËØçÂáÜÂ§áÊåâÈïøÂ∫¶ÈôçÂ∫èÁöÑËØçË°®ÔºàËøáÊª§ÁâπÊÆäÁ¨¶Âè∑Ôºâ
                __ctcCtx.sortedTokens = Array.from(token2id.keys()).filter(t=>!t.startsWith('<')).sort((a,b)=>b.length-a.length);
                return __ctcCtx;
            }
            return null;
        }
        function __softmaxLogits2LogProbs(logits){
            // logits: Float32Array [T,V] Êàñ [V,T] ÂùáÊîØÊåÅÔºàÊåâ [T,V] Â§ÑÁêÜÔºåÂøÖË¶ÅÊó∂ËΩ¨ÁΩÆÔºâ
            const T = logits.T || 0, V = logits.V || 0; // ÂÖÅËÆ∏Êê∫Â∏¶ÂÖÉ‰ø°ÊÅØ
            if (!T || !V) return null;
            const out = new Float32Array(T*V); out.T=T; out.V=V;
            for (let t=0; t<T; t++){
                let maxv=-1e30; for (let v=0; v<V; v++){ const x = logits[t*V+v]; if (x>maxv) maxv=x; }
                let sum=0; for (let v=0; v<V; v++){ sum += Math.exp(logits[t*V+v]-maxv); }
                const lsum = Math.log(sum) + maxv;
                for (let v=0; v<V; v++){ out[t*V+v] = logits[t*V+v] - lsum; }
            }
            return out;
        }
        async function ensureCTCSession(){
            if (__ctcCtx.session) return __ctcCtx;
            const ok = await ensureORT(); if (!ok) return null;
            const art = await __ensureCTCArtifacts(); if (!art) return null;
            try{
                __ctcCtx.session = await ort.InferenceSession.create(art.modelUrl, { executionProviders: __guessProviders() });
                __ctcCtx.ready = true; return __ctcCtx;
            }catch(e){ console.warn('CTC session create failed:', e); return null; }
        }
        function __normalizePCM(pcm){
            // ËæìÂÖ•ÂèØËÉΩÊòØ Float32 [-1,1]Ôºå‰πüÂèØËÉΩÊòØ Int16 Êï∞ÁªÑÔºà-32768..32767Ôºâ
            let out;
            // Âà§ÂÆöÊòØÂê¶ÂÉèÊï¥ÂûãÂπÖÂ∫¶ÔºöÂèñËã•Âπ≤ÈááÊ†∑‰º∞ÁÆóÊúÄÂ§ßÁªùÂØπÂÄº
            let mxAbs = 0; const step = Math.max(1, Math.floor(pcm.length/64));
            for (let i=0;i<pcm.length;i+=step){ const a = Math.abs(pcm[i]); if (a>mxAbs) mxAbs=a; }
            if (mxAbs > 2){
                // ËßÜ‰∏∫Êï¥ÂûãÂπÖÂ∫¶ÔºåÁº©ÊîæÂà∞ [-1,1]
                out = new Float32Array(pcm.length);
                for (let i=0;i<pcm.length;i++){ out[i] = pcm[i] / 32768; }
            } else {
                // ËßÜ‰∏∫Â∑≤ÊòØ [-1,1]
                out = new Float32Array(pcm);
            }
            // ÂΩí‰∏ÄÂåñÂà∞Â≥∞ÂÄº 0.95ÔºåÈÅøÂÖçÊ∫¢Âá∫
            let mx=0; for(let i=0;i<out.length;i++){ const a=Math.abs(out[i]); if(a>mx) mx=a; }
            const g = mx>0? 0.95/mx : 1; if (g!==1){ for(let i=0;i<out.length;i++) out[i]*=g; }
            return out;
        }
        async function __runCTC(pcm16k){
            const ctx = await ensureCTCSession(); if (!ctx || !ctx.session) return null;
            try{
                const x = __normalizePCM(pcm16k);
                // ÊåâÁúüÂÆûËæìÂÖ•ÂêçÂñÇÂÖ•ÔºöÊúâ length / len / x_len / x_lens Â∞±ÂêåÊ≠•Êèê‰æõ
                const names = ctx.session.inputNames || [];
                const feeds = {};
                // Â∏∏ËßÅ‰∏ªËæìÂÖ•
                const mainName = names.find(n => /input|waveform|audio|x$/i.test(n)) || names[0] || 'input';
                feeds[mainName] = new ort.Tensor('float32', x, [1, x.length]);

                const lenName = names.find(n => /length|lens|len/i.test(n));
                if (lenName) {
                    // Int32 Êõ¥ÈÄöÁî®ÔºõÊúâÁöÑÊ®°ÂûãË¶Å int64ÔºåËã•ÈúÄË¶ÅÂèØÂÜçÂä†‰∏ÄÊù°ÂàÜÊîØ
                    feeds[lenName] = new ort.Tensor('int32', Int32Array.from([x.length]), [1]);
                }

                const out = await ctx.session.run(feeds);
                const firstKey = Object.keys(out)[0]; const y = out[firstKey];
                let data = y.data, T=0,V=0;
                if (y.dims.length===3){ T=y.dims[1]; V=y.dims[2]; }
                else if (y.dims.length===2){ T=y.dims[0]; V=y.dims[1]; }
                else { return null; }

                const logits = new Float32Array(T*V); logits.T=T; logits.V=V;
                logits.set(data.subarray(0, T*V));
                const logProbs = __softmaxLogits2LogProbs(logits);
                return { logProbs, T, V };
            }catch(e){
                console.warn('CTC run failed (fallback to proxy):', e);
                return null;
            }
        }
        function __avgLogProbForRef(logProbs, tokenSeq){
            // ÁÆÄÂåñÁâà CTC ÂØπÈΩêÔºöË¥™ÂøÉÂèñÊØèÂ∏ßÊúÄÂ§ßÁ±ªÔºåÁªüËÆ°‰∏é ref ÁöÑÂåπÈÖçË¶ÜÁõñÁéáÔºåËæìÂá∫ÂØπÈΩêÁöÑÂπ≥Âùá logprob
            const { T, V } = logProbs; const arr = logProbs;
            const best = new Int32Array(T);
            for (let t=0;t<T;t++){
                let bi=0, bv=-1e9; for(let v=0;v<V;v++){ const lp = arr[t*V+v]; if (lp>bv){ bv=lp; bi=v; } }
                best[t]=bi;
            }
            // Â∞Ü ref ÈÄê‰∏™ token Âú®Êó∂Èó¥‰∏äË¥™ÂøÉÂåπÈÖç
            let ti=0; const lps=[]; for (const tok of tokenSeq){ const id = __ctcCtx.token2id.get(tok); if(id==null) continue; while(ti<T && best[ti]!==id) ti++; if (ti<T){ lps.push(arr[ti*V+id]); ti++; } }
            if (!lps.length) return -10; // ÊûÅ‰Ωé
            const avg = lps.reduce((s,x)=>s+x,0)/lps.length;
            return avg;
        }
        async function tryComputeRealGOP(pcm16k, sr, refWords){
            // Ëã• CTC ‰∏çÂèØÁî®ÂàôÂõûÈÄÄ
            const r = await __runCTC(pcm16k);
            if (!r || !r.logProbs) return null;
            const { logProbs } = r; const T = logProbs.T, V = logProbs.V; const arr = logProbs;
            const totalSec = (pcm16k.length||0) / (sr||16000); const frameDur = totalSec / Math.max(1,T);

            // ÂèÇËÄÉÊñáÊú¨ -> Ê®°Âûã tokensÔºàSPM Ë¥™ÂøÉÂàÜËØçÔºâ
            const refText = (refWords||[]).join(' ');
            const spmTokens = (function __tokenize(text){
                const ctx = __ctcCtx; if (!ctx || !ctx.sortedTokens) return [];
                const cleaned = (text||'').replace(/[^A-Za-z' ]+/g,' ').trim();
                if (!cleaned) return [];
                const spm = '‚ñÅ' + cleaned.replace(/\s+/g,' ‚ñÅ');
                const toks = []; let i=0; const vocab = ctx.sortedTokens;
                while (i < spm.length){
                    let matched = null;
                    for (let k=0;k<vocab.length;k++){
                        const tk = vocab[k];
                        if (spm.startsWith(tk, i)){ matched = tk; break; }
                    }
                    if (matched){ toks.push(matched); i += matched.length; }
                    else { i += 1; }
                }
                return toks;
            })(refText);
            // ÊûÑÂª∫ SPM -> refIds ÁöÑÁ¥¢ÂºïÊò†Â∞ÑÔºåËøáÊª§ÊéâËØçË°®‰∏≠‰∏çÂ≠òÂú®ÁöÑ token
            const idPerSpm = spmTokens.map(t=>__ctcCtx.token2id.get(t));
            const spmToRef = new Int32Array(spmTokens.length); spmToRef.fill(-1);
            const refIds = []; const filteredSpmIdx = [];
            for (let i=0;i<spmTokens.length;i++){
                const id = idPerSpm[i]; if (id!=null){ spmToRef[i] = refIds.length; refIds.push(id); filteredSpmIdx.push(i); }
            }
            if (!refIds.length) return null;

            // Â∏ßÁ∫ßÊúÄ‰ºòË∑ØÂæÑÔºàargmaxÔºâ
            const bestId = new Int32Array(T);
            for (let t=0;t<T;t++){
                let bi=0, bv=-1e9; for(let v=0;v<V;v++){ const lp=arr[t*V+v]; if(lp>bv){ bv=lp; bi=v; } }
                bestId[t]=bi;
            }

            // Ë¥™ÂøÉÂØπÈΩêÔºö‰∏∫ÊØè‰∏™ÂèÇËÄÉ token ÊâæÂà∞ÊúÄÊó©ÂåπÈÖçÂ∏ß
            const align = new Int32Array(refIds.length).fill(-1);
            let pos=0; for (let i=0;i<refIds.length;i++){
                const id = refIds[i]; let found=-1; for (let t=pos;t<T;t++){ if (bestId[t]===id){ found=t; break; } }
                if (found>=0){ align[i]=found; pos=found+1; } else { align[i]=-1; }
            }
            // Áî®Á∫øÊÄßÊèíÂÄº/Âπ≥ÂùáÂàÜÂ∏ÉÂ°´Ë°• -1
            const nTok = align.length;
            const known = []; for (let i=0;i<nTok;i++) if (align[i]>=0) known.push(i);
            if (!known.length){ for (let i=0;i<nTok;i++) align[i] = Math.floor((i+1)*T/(nTok+1)); }
            else {
                // ÂâçÊÆµÁº∫Â§±
                const first=known[0]; for (let i=0;i<first;i++){ align[i] = Math.floor((i+1)*align[first]/(first+1)); }
                // ‰∏≠Èó¥ÊÆµ
                for (let k=0;k<known.length-1;k++){
                    const a=known[k], b=known[k+1]; const left=align[a], right=align[b]; const span=b-a; for (let i=a+1;i<b;i++){
                        const rti = i-a; align[i] = Math.floor(left + rti*(right-left)/span);
                    }
                }
                // Êú´ÊÆµÁº∫Â§±
                const last = known[known.length-1]; for (let i=last+1;i<nTok;i++){ align[i] = Math.floor(align[last] + (i-last)*(T-1-align[last])/(nTok-1-last+1e-6)); }
            }
            // ÊûÑÈÄ†ËæπÁïå b[0..nTok]
            const b = new Int32Array(nTok+1); b[0]=0; b[nTok]=T;
            for (let i=1;i<nTok;i++){
                b[i] = Math.floor((align[i-1] + align[i]) / 2);
                if (b[i] <= b[i-1]) b[i] = Math.min(T-1, b[i-1]+1);
            }

            // token Âå∫ÊÆµÂπ≥ÂùáÂØπÊï∞ÂêéÈ™å
            const tokenScoresLog = new Float32Array(nTok);
            for (let i=0;i<nTok;i++){
                const id = refIds[i]; const s=b[i], e=b[i+1]; let sum=0, cnt=0;
                for (let t=s; t<e; t++){ sum += arr[t*V+id]; cnt++; }
                if (cnt===0){ tokenScoresLog[i] = -10; } else { tokenScoresLog[i] = sum/cnt; }
            }

            // Âü∫‰∫é SPM ÁöÑ‚ÄúËØç‚ÄùÂàÜÁªÑÔºà‰ª• ‚ñÅ ‰Ωú‰∏∫ËØçËµ∑ÂßãÔºâÔºåÂπ∂ÊäïÂΩ±Âà∞ËøáÊª§ÂêéÁöÑ ref token Á¥¢Âºï
            const wordTokenGroupsSpm = []; let cur=[];
            for (let i=0;i<spmTokens.length;i++){
                const tk = spmTokens[i]; if (tk.startsWith('‚ñÅ')){ if (cur.length) wordTokenGroupsSpm.push(cur); cur=[i]; } else { cur.push(i); }
            }
            if (cur.length) wordTokenGroupsSpm.push(cur);
            const wordTokenGroups = wordTokenGroupsSpm.map(group=> group.map(i=>spmToRef[i]).filter(j=>j>=0) ).filter(g=>g.length>0);
            // Â∞Ü groups Êà™Êñ≠/ÂØπÈΩêÂà∞ refWords ÈïøÂ∫¶
            const targetWordCount = (refWords||[]).length; if (targetWordCount>0 && wordTokenGroups.length>targetWordCount){ wordTokenGroups.length = targetWordCount; }

            // ËØçÁ∫ßÊó∂Èó¥ÔºàÂ∏ßÔºâ
            const wordsTiming = wordTokenGroups.map(group=>{
                const firstTok = group[0], lastTok = group[group.length-1];
                const s = (firstTok < nTok) ? b[firstTok] : 0;
                const e = (lastTok+1 <= nTok) ? b[lastTok+1] : T;
                return { s, e };
            });

            // ÂèñÂ≠óÂÖ∏Èü≥Á¥†
            const dict = await ensurePhonemeDict();
            function stripStress(p){ return (p||'').replace(/[0-2]$/,''); }
            function getWordPhones(w){
                const key = (w||'').toUpperCase(); const arr = dict[key];
                let phones = Array.isArray(arr) && arr.length ? arr[0] : null;
                if (!phones){ phones = __simpleG2P(w); }
                if (!Array.isArray(phones)) phones = [String(phones||'').toUpperCase()].filter(Boolean);
                return phones.map(stripStress);
            }
            function isVowel(p){ return __VOWELS.includes(stripStress(p)); }

            // Â∞ÜËØçÊó∂Èó¥ÊåâÈü≥Á¥†Âä†ÊùÉÂàÜÈÖç
            const phAlign = []; // {ph, startSec, endSec, score}
            for (let wi=0; wi<wordsTiming.length; wi++){
                const w = (refWords||[])[wi] || '';
                const { s:eS=0, e:eE=T } = wordsTiming[wi]||{}; const s = eS, e = eE;
                const frames = Math.max(0, e - s);
                const phs = getWordPhones(w);
                if (!phs.length || frames<=0) continue;
                const weights = phs.map(p=> isVowel(p)?1.4:1.0 );
                const W = weights.reduce((a,x)=>a+x,0) || 1;
                let alloc = phs.map((_,i)=> Math.max(1, Math.round(weights[i]/W * frames)) );
                // Ë∞ÉÊï¥ÊÄªÂíå
                let diff = frames - alloc.reduce((a,x)=>a+x,0);
                for (let k=0; diff!==0 && k<alloc.length; k=(k+1)%alloc.length){ if (diff>0){ alloc[k]++; diff--; } else if (alloc[k]>1){ alloc[k]--; diff++; } }
                // ÈÄêÈü≥Á¥†Âå∫ÊÆµËØÑÂàÜÔºöÂèñËØ•Âå∫ÊÆµÂ∏ßÁöÑ‚ÄúÂ∏ßÊúÄÂ§ßÁ±ª‚ÄùÁöÑÂØπÊï∞Ê¶ÇÁéáÂπ≥Âùá
                let curS = s;
                for (let pi=0; pi<phs.length; pi++){
                    const len = alloc[pi]; const ps = curS; const pe = Math.min(T, ps + len); curS = pe;
                    if (pe<=ps) continue;
                    let sumLog=0, cnt=0; for (let t=ps; t<pe; t++){ let bv=-1e9; for (let v=0; v<V; v++){ const lp = arr[t*V+v]; if (lp>bv) bv=lp; } sumLog += bv; cnt++; }
                    const avgLog = cnt? (sumLog/cnt) : -10;
                    const phScore = Math.round(clamp((avgLog + 5)/5, 0, 1) * 100);
                    phAlign.push({ ph: stripStress(phs[pi]), startSec: ps*frameDur, endSec: pe*frameDur, score: phScore, word: w });
                }
            }

            if (!phAlign.length){
                // ÂõûÈÄÄÂà∞ token Âπ≥ÂùáÂàÜ
                const avgTok = tokenScoresLog.reduce((s,x)=>s+x,0)/Math.max(1, tokenScoresLog.length);
                const score = Math.round(clamp((avgTok + 5)/5, 0, 1) * 100);
                return { score, weakPhonemes: [], phonemeCount: 0, method: 'ctc' };
            }

            // ------- logistic Ê†°ÂáÜÔºàtoken Âπ≥ÂùáÂØπÊï∞ÂêéÈ™å vs blank Âü∫Á∫øÔºâ -------
            const valid = Array.from(tokenScoresLog).filter(x => isFinite(x) && x > -10);
            const avgLP = valid.length ? valid.reduce((s,x)=>s+x,0)/valid.length : -10;
            const bid = (__ctcCtx && __ctcCtx.blankId!=null) ? __ctcCtx.blankId : 0;
            let blankSum = 0, blankCnt = 0; for (let t=0;t<T;t++){ blankSum += arr[t*V + bid]; blankCnt++; }
            const blankAvg = blankCnt ? (blankSum/blankCnt) : -2.5;
            const coverage = valid.length / Math.max(1, tokenScoresLog.length);
            const margin = avgLP - blankAvg;
            const s = 1 / (1 + Math.exp(-(margin + 1.2) * 1.8));
            let ph = s; ph = clamp01(ph * (0.7 + 0.6*coverage));
            const overall = Math.round(ph*100);

            // Âº±ÁÇπÈü≥Á¥†Ôºö‰ªçÊåâÂå∫ÊÆµÂàÜÊï∞ÊåëÊúÄ‰ΩéÁöÑÂá†‰∏™Â±ïÁ§∫Ôºà‰∏çÊãâÂàÜÔºâ
            const sorted = [...phAlign].sort((a,b)=>a.score-b.score);
            const low = sorted.filter(x=>x.score<70).slice(0,3);
            const pick = (low.length? low : sorted.slice(0,3));
            const weakPhonemes = Array.from(new Set(pick.map(x=>x.ph))).slice(0,3);

            return { score: overall, weakPhonemes, phonemeCount: phAlign.length, method: 'ctc', phonemeAlignment: phAlign };
        }
        async function ensurePhonemeDict(){
            if (__phonemeDict) return __phonemeDict;
            if (__phonemeDictLoading) return __phonemeDictLoading;
            const paths = [
                '../Old_code/AI Pronunciation Coach/public/data/en_US.json',
                '../Old_code/AI%20Pronunciation%20Coach/public/data/en_US.json',
                '../Old_code/AI Pronunciation Coach/src/data/en_US.json',
                '../Old_code/AI%20Pronunciation%20Coach/src/data/en_US.json',
                '/public/data/en_US.json',
                '/Old_code/AI Pronunciation Coach/public/data/en_US.json',
                '/Old_code/AI%20Pronunciation%20Coach/public/data/en_US.json',
                './data/en_US.json',
                'data/en_US.json'
            ];
            __phonemeDictLoading = (async ()=>{
                for (const p of paths){
                    try{ const r = await fetch(p); if(r.ok){ const j = await r.json(); __phonemeDict = j||{}; return __phonemeDict; } }catch{}
                }
                __phonemeDict = {}; return __phonemeDict;
            })();
            return __phonemeDictLoading;
        }
        const __VOWELS = ['AA','AE','AH','AO','AW','AY','EH','ER','EY','IH','IY','OW','OY','UH','UW'];
        function __simpleG2P(word){
            // ÊûÅÁÆÄÂõûÈÄÄËßÑÂàôÔºà‰ªÖÂΩìÂ≠óÂÖ∏Áº∫Â§±Êó∂ÔºâÔºåËæìÂá∫ ARPABET Ëøë‰ºº
            let w = (word||'').toLowerCase();
            // Â§ÑÁêÜÈÉ®ÂàÜ‰∫åÂêàÂ≠óÊØç
            w = w.replace(/ng/g,' NG ').replace(/ch/g,' CH ').replace(/sh/g,' SH ').replace(/th/g,' TH ').replace(/zh/g,' ZH ').replace(/ph/g,' F ');
            w = w.replace(/[^a-z'+ ]/g,' ');
            const letters = w.trim().split(/\s+/);
            const phones = [];
            for (const l of letters){
                if (l === 'ng') { phones.push('NG'); continue; }
                const c = l[0];
                switch(c){
                    case 'a': phones.push('AE'); break; case 'e': phones.push('EH'); break;
                    case 'i': phones.push(l.length>1?'AY':'IH'); break; case 'o': phones.push('OW'); break; case 'u': phones.push('UW'); break; case 'y': phones.push('Y'); break;
                    case 'b': phones.push('B'); break; case 'c': phones.push('K'); break; case 'd': phones.push('D'); break; case 'f': phones.push('F'); break; case 'g': phones.push('G'); break;
                    case 'h': phones.push('HH'); break; case 'j': phones.push('JH'); break; case 'k': phones.push('K'); break; case 'l': phones.push('L'); break; case 'm': phones.push('M'); break; case 'n': phones.push('N'); break;
                    case 'p': phones.push('P'); break; case 'q': phones.push('K'); phones.push('W'); break; case 'r': phones.push('R'); break; case 's': phones.push('S'); break; case 't': phones.push('T'); break; case 'v': phones.push('V'); break;
                    case 'w': phones.push('W'); break; case 'x': phones.push('K'); phones.push('S'); break; case 'z': phones.push('Z'); break; default: break;
                }
            }
            // Á°Æ‰øùËá≥Â∞ë‰∏Ä‰∏™ÂÖÉÈü≥
            if (!phones.some(p=>__VOWELS.includes(p))) phones.push('AH');
            return phones;
        }
        function g2pWordCMU(word){
            const dict = __phonemeDict; if (!dict) return __simpleG2P(word);
            const key = (word||'').toUpperCase();
            const e = dict[key];
            if (Array.isArray(e) && e.length){
                // e ÂèØËÉΩÊòØÂ≠óÁ¨¶‰∏≤ÊàñÊï∞ÁªÑÔºõÁªü‰∏Ä‰∏∫Êï∞ÁªÑÁ¨¨‰∏ÄÊù°
                let p = e[0];
                if (Array.isArray(p)) p = p.join(' ');
                if (typeof p === 'string'){
                    return p.trim().split(/\s+/).map(ph=>ph.replace(/[0-9]$/,''));
                }
            }
            return __simpleG2P(word);
        }
        function wordsToPhones(words){ return words.flatMap(w=> g2pWordCMU(w)); }
        function buildPhonemeTimeline(words, perSec, phones){
            // Â∞ÜÊØè‰∏™ËØçÁöÑÊó∂ÈïøÂùáÂàÜÂà∞ÂÖ∂Èü≥Á¥†
            const timeline = []; let t = 0; let pi = 0;
            for(let wi=0; wi<words.length; wi++){
                const w = words[wi]; const dur = perSec[wi] || 0.3; // ÈªòËÆ§ 0.3s
                // ÂèñËØ•ËØçÁöÑÈü≥Á¥†ÁâáÊÆµÔºàÁÆÄÂçïÔºöÊåâÂ≠óÊØçËøë‰ºº‰∏™Êï∞/ÊàñÊåâ phones ËøûÁª≠ÂàáÂèñÔºâ
                const phs = []; while (pi<phones.length && phs.length<Math.max(1, Math.ceil(w.length/3))){ phs.push(phones[pi++]); }
                const n = Math.max(1, phs.length);
                const pd = dur / n; let st = t;
                for(const p of phs){ const ed = st + pd; timeline.push({ p, start: st, end: ed }); st = ed; }
                t += dur;
            }
            return timeline;
        }
        function segmentStats(pcm, sr, st, ed){
            const a = Math.max(0, Math.floor(st*sr)); const b = Math.min(pcm.length, Math.ceil(ed*sr));
            if (b<=a+4) return { rms:0, zcr:0, f0:0, f0Valid:false, r:0 };
            const seg = pcm.slice(a,b);
            const rms = Math.sqrt(mean(seg.map(x=>x*x)));
            const zcr = zeroCrossRate(seg);
            // Âèñ‰∏≠Èó¥ 50% ÂÅö ACF F0
            const midA = a + Math.floor((b-a)*0.25); const midB = a + Math.floor((b-a)*0.75);
            const frame = pcm.slice(midA, midB);
            const fr = estimateF0ACF(frame, sr, 80, 350) || { f0:0, r:0 };
            const f0 = fr.f0 || 0; const r = fr.r || 0;
            return { rms, zcr, f0, f0Valid: f0>60, r };
        }
        function computeProxyGOP(pcm, sr, timeline){
            const statsList = [];
            for (const seg of timeline){
                const st = seg.start, ed = seg.end;
                const stt = segmentStats(pcm, sr, st, ed);
                statsList.push({ ...stt, p: seg.p, start: st, end: ed });
            }
            const rmss = statsList.map(s=>s.rms);
            const zcrs = statsList.map(s=>s.zcr);
            const rmsMed = median(rmss);
            const rmsP90 = percentile(rmss, 90);
            const zMed = median(zcrs);
            const zWidth = Math.max(0.12, 0.5 * std(zcrs));
            const scores = [];
            for (const stt of statsList){
                const vol = clamp01((stt.rms - rmsMed*0.6) / ((rmsP90 - rmsMed*0.6) + 1e-6));
                const zcrGood = 1 - clamp01(Math.abs(stt.zcr - zMed) / zWidth);
                const f0ok = clamp01(stt.r || 0);
                const s = clamp01(0.4*vol + 0.2*zcrGood + 0.4*f0ok);
                scores.push({ p: stt.p, score: s, start: stt.start, end: stt.end });
            }
            const avg = scores.length? mean(scores.map(x=>x.score)) : 0;
            return { scores, avg };
        }
        async function computeAdvancedPronScore(pcm16k, sr, refWords){
            try{ await ensurePhonemeDict(); }catch{}
            // ‰ºòÂÖàÂ∞ùËØïÁúüÂÆû GOPÔºàORT-Web + CTCÔºâÔºåÂ§±Ë¥•ÂàôÂõûÈÄÄÂêØÂèëÂºè
            try {
                if (typeof tryComputeRealGOP === 'function'){
                    const real = await tryComputeRealGOP(pcm16k, sr, refWords);
                    if (real && Number.isFinite(real.score)) return real;
                }
            } catch {}
            const { perWordSec } = computeDurationsFromTokens();
            const phones = wordsToPhones(refWords);
            const timeline = buildPhonemeTimeline(refWords, perWordSec, phones);
            const proxy = computeProxyGOP(pcm16k, sr, timeline);
            const advScore = Math.round(proxy.avg*100);
            const weak = proxy.scores.slice().sort((a,b)=>a.score-b.score).slice(0,3).map(x=>x.p);
            return { score: advScore, weakPhonemes: weak, phonemeCount: proxy.scores.length, method: 'proxy' };
        }

        // ====== Á¶ªÁ∫ø ASRÔºàVosk WASMÔºâÈõÜÊàêÔºöWER/ÂØπÈΩê ======
        let __voskLoading = null, __voskModel = null, __voskRec = null;
        async function loadVoskUMD(){
            if (window.Vosk) return;
            await new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = 'https://cdn.jsdelivr.net/npm/vosk-browser@0.0.5/dist/vosk.js';
                s.onload = resolve;
                s.onerror = () => {
                    const s2 = document.createElement('script');
                    s2.src = 'https://cdn.jsdelivr.net/npm/vosk-browser@0.0.8/dist/vosk.js';
                    s2.onload = resolve;
                    s2.onerror = reject;
                    document.head.appendChild(s2);
                };
                document.head.appendChild(s);
            });
        }
        async function ensureVoskRecognizer(){
            if (__voskRec) return __voskRec;
            if (__voskLoading) return __voskLoading;
            __voskLoading = (async () => {
                await loadVoskUMD();
                const paths = [
                    '../Old_code/AI Pronunciation Coach/public/models/vosk-model-small-en-us-0.15',
                    '../Old_code/AI%20Pronunciation%20Coach/public/models/vosk-model-small-en-us-0.15'
                ];
                let model = null;
                for (const p of paths){
                    try { model = await window.Vosk.createModel(p); break; } catch(e) {}
                }
                if (!model) throw new Error('Vosk Ê®°ÂûãÂä†ËΩΩÂ§±Ë¥•ÔºàËØ∑Á°ÆËÆ§ models ÁõÆÂΩïË∑ØÂæÑÂèØËÆøÈóÆÔºâ');
                let rec = null;
                if (typeof model.createRecognizer === 'function') {
                    rec = await model.createRecognizer(16000);
                } else if (window.Vosk && (window.Vosk.Recognizer || window.Vosk.KaldiRecognizer)) {
                    const Ctor = window.Vosk.Recognizer || window.Vosk.KaldiRecognizer;
                    try { rec = new Ctor(model, 16000); } catch { rec = new Ctor({ model, sampleRate: 16000 }); }
                }
                if (!rec) throw new Error('Êó†Ê≥ïÂàõÂª∫ Vosk ËØÜÂà´Âô®');
                if (typeof rec.setWords === 'function') rec.setWords(true);
                __voskModel = model; __voskRec = rec; return rec;
            })();
            return __voskLoading;
        }
        function f32ToI16(f){ const out = new Int16Array(f.length); for(let i=0;i<f.length;i++){ let s = Math.max(-1, Math.min(1, f[i]||0)); out[i] = s < 0 ? s*32768 : s*32767; } return out; }
        async function runVoskOnPCM(pcm16k){
            const rec = await ensureVoskRecognizer();
            try { if (typeof rec.reset === 'function') rec.reset(); } catch {}
            const i16 = f32ToI16(pcm16k);
            const chunkSize = 16000; // 1s/chunk at 16kHz
            function parseRes(r){
                if (!r) return null;
                if (typeof r === 'string') { try { r = JSON.parse(r); } catch { return null; } }
                return r;
            }
            let words = [];
            let text = '';
            for (let off = 0; off < i16.length; off += chunkSize){
                const slice = i16.subarray(off, Math.min(off + chunkSize, i16.length));
                try { rec.acceptWaveform(slice); } catch { try { rec.acceptWaveform(Array.from(slice)); } catch {}
                }
                const pr = (typeof rec.partialResult === 'function') ? parseRes(rec.partialResult()) : null;
                if (pr && Array.isArray(pr.result)){
                    words.push(...pr.result);
                    text = pr.text || text;
                } else if (pr && pr.text && !text){
                    text = pr.text;
                }
            }
            const fr = (typeof rec.finalResult === 'function') ? parseRes(rec.finalResult()) : (typeof rec.result === 'function' ? parseRes(rec.result()) : null);
            if (fr){
                if (Array.isArray(fr.result)) words.push(...fr.result);
                if (Array.isArray(fr.alternatives) && fr.alternatives.length){
                    const alt = fr.alternatives[0];
                    if (Array.isArray(alt.result) && (!words || words.length === 0)) words = alt.result.slice();
                    if (!fr.text && alt.text) text = alt.text;
                }
                text = fr.text || text || (Array.isArray(words)? words.map(w=>w.word).join(' ') : '');
            }
            return { words, text };
        }
        function normalizeWord(w){ return (w||'').toLowerCase().replace(/[^a-z']+/g,'').replace(/^'+|'+$/g,''); }
        function getRefWords(){
            const container = (mode === 'single') ? (singleTokens || document) : (fullSection || document);
            const els = Array.from(container.querySelectorAll('.token .word'));
            return els.map(el => normalizeWord(el.textContent)).filter(Boolean);
        }
        function alignWER(ref, hyp){
            const n = ref.length, m = hyp.length;
            // Ëøë‰ººÂåπÈÖçÔºöÂÖÅËÆ∏ËΩªÂæÆÊãºÂÜôÂ∑ÆÂºÇ„ÄÅËøûËØª„ÄÅÊºèÂ≠óÁ¨¶‰ª•Êõ¥ÂÆΩÂÆπÂú∞ËØÑ‰º∞‚ÄúÊ†áÂáÜÊúóËØª‚Äù
            function levenshtein(a, b, maxd=2){
                if (a===b) return 0;
                const la=a.length, lb=b.length;
                if (Math.abs(la-lb)>maxd) return maxd+1;
                const dp = new Array(lb+1);
                for (let j=0;j<=lb;j++) dp[j]=j;
                for (let i=1;i<=la;i++){
                    let prev = dp[0];
                    dp[0]=i;
                    let minRow = dp[0];
                    for (let j=1;j<=lb;j++){
                        const temp = dp[j];
                        const cost = (a[i-1]===b[j-1])?0:1;
                        dp[j] = Math.min(
                            dp[j] + 1,      // del in b (ins in a)
                            dp[j-1] + 1,    // ins in b (del in a)
                            prev + cost     // sub
                        );
                        prev = temp;
                        if (dp[j] < minRow) minRow = dp[j];
                    }
                    if (minRow > maxd) return maxd+1; // ÊèêÂâçÂâ™Êûù
                }
                return dp[lb];
            }
            function subCost(a, b){
                if (!a || !b) return 1.0;
                if (a===b) return 0;
                const d = levenshtein(a,b,2);
                if (d<=1) return 0.3; // ÊûÅËøë‰ººÔºöI'm vs Im, color vs colr
                if (d===2) return 0.6; // ËΩªÂæÆÂ∑ÆÂºÇ
                return 1.0;            // ÊòéÊòæ‰∏çÂêå
            }
            const DEL = 1.0, INS = 0.6; // ÊèíÂÖ•Áï•ËΩªÁΩöÔºåÂà†Èô§ÈáçÁΩö
            const dp = Array.from({length: n+1}, () => Array(m+1).fill(0));
            const bt = Array.from({length: n+1}, () => Array(m+1).fill(''));
            for(let i=0;i<=n;i++){ dp[i][0]=i*DEL; bt[i][0]='del'; }
            for(let j=0;j<=m;j++){ dp[0][j]=j*INS; bt[0][j]='ins'; }
            bt[0][0]='';
            for(let i=1;i<=n;i++){
                for(let j=1;j<=m;j++){
                    if (ref[i-1] === hyp[j-1]){ dp[i][j]=dp[i-1][j-1]; bt[i][j]='ok'; }
                    else {
                        const sc = subCost(ref[i-1], hyp[j-1]);
                        const del = dp[i-1][j] + DEL;
                        const ins = dp[i][j-1] + INS;
                        const sub = dp[i-1][j-1] + sc;
                        const min = Math.min(del, ins, sub);
                        dp[i][j]=min;
                        bt[i][j] = (min===sub ? (sc<=0.6 ? 'subNear' : 'sub') : (min===del ? 'del' : 'ins'));
                    }
                }
            }
            let i=n, j=m; const aligned=[]; let ok=0, sub=0, subNear=0, del=0, ins=0;
            while(i>0 || j>0){
                const b = bt[i][j];
                if (i>0 && j>0 && (b==='ok' || b==='sub' || b==='subNear')){
                    // ÂØπ UI Áª¥ÊåÅ 'sub' Ê†áËÆ∞ÔºåÁªÜÂàÜËÆ°Êï∞Âú® counts ‰∏≠‰ΩìÁé∞
                    aligned.push({ type: (b==='ok'?'ok':'sub'), ref: ref[i-1], hyp: hyp[j-1], refIndex: i-1, hypIndex: j-1 });
                    if (b==='ok') ok++; else if (b==='subNear') subNear++; else sub++;
                    i--; j--;
                } else if (i>0 && (j===0 || b==='del')){
                    aligned.push({ type: 'del', ref: ref[i-1], hyp: null, refIndex: i-1, hypIndex: null });
                    del++; i--;
                } else {
                    aligned.push({ type: 'ins', ref: null, hyp: hyp[j-1], refIndex: null, hypIndex: j-1 });
                    ins++; j--;
                }
            }
            aligned.reverse();
            const werClassic = n ? ((sub + subNear + del + ins) / n) : 0;
            const werWeighted = n ? (dp[n][m] / n) : 0;
            return { wer: werClassic, werWeighted, aligned, counts: { ok, sub, subNear, del, ins } };
        }
        // Ê†áÊ≥®ÂØπÈΩêÁªìÊûúÂà∞ UIÔºàÈÄêËØçÔºâ
        function clearAccuracyHighlights(){
            try{
                const container = (mode === 'single') ? (singleTokens || document) : (fullSection || document);
                const tks = Array.from(container.querySelectorAll('.token'));
                for (const tk of tks){
                    tk.removeAttribute('data-acc');
                    tk.style.outline = '';
                    tk.style.outlineOffset = '';
                    tk.style.backgroundColor = '';
                }
            }catch{}
        }
        function applyAlignmentToTokens(aligned){
            const container = (mode === 'single') ? (singleTokens || document) : (fullSection || document);
            const wordEls = Array.from(container.querySelectorAll('.token .word'));
            for (const a of aligned){
                if (a.refIndex != null && wordEls[a.refIndex]){
                    const tk = wordEls[a.refIndex].closest('.token');
                    if (!tk) continue;
                    tk.dataset.acc = a.type;
                    if (a.type === 'ok'){
                        tk.style.outline = '2px solid #22c55e';
                        tk.style.outlineOffset = '2px';
                        tk.style.backgroundColor = 'rgba(34,197,94,0.08)';
                    } else if (a.type === 'sub'){
                        tk.style.outline = '2px solid #ef4444';
                        tk.style.outlineOffset = '2px';
                        tk.style.backgroundColor = 'rgba(239,68,68,0.08)';
                    } else if (a.type === 'del'){
                        tk.style.outline = '2px dashed #f59e0b';
                        tk.style.outlineOffset = '2px';
                        tk.style.backgroundColor = 'rgba(245,158,11,0.08)';
                    }
                }
            }
        }
        async function computeAndRenderScore(blob){
            // ËØÑÂàÜÈó®ÊéßÔºöÂÖ≥Èó≠Âàô‰ªÖÊèêÁ§∫ÔºåÂπ∂Ë∑≥ËøáËÆ°ÁÆó
            if (typeof scoringEnabled !== 'undefined' && !scoringEnabled) {
                const scoreSection = document.getElementById('scoreSection');
                const scoreSummary = document.getElementById('scoreSummary');
                const scoreDetails = document.getElementById('scoreDetails');
                if (scoreSection) scoreSection.hidden = false;
                if (scoreSummary) { scoreSummary.textContent = 'ËØÑÂàÜÂäüËÉΩÂ∑≤ÂÖ≥Èó≠ÔºåÂ¶ÇÈúÄËØ∑ÊâìÂºÄÈ°∂ÈÉ®ËØÑÂàÜÊåâÈíÆ'; scoreSummary.style.color = '#C4C4C4'; }
                if (scoreDetails) scoreDetails.textContent = '';
                return;
            }
            if (window.__scoringBusy) { console.warn('scoring in progress, skip'); return; }
            window.__scoringBusy = true;
            // ‰∏∫‰∏ÄÊ¨°ËØÑÂàÜÁîüÊàê‰ª§ÁâåÔºåÈÅøÂÖçÂºÇÊ≠• WER Ê±°ÊüìÂêéÁª≠ËØÑÂàÜ
            window.__scoringToken = (window.__scoringToken || 0) + 1;
            const __token = window.__scoringToken;
            try{
                // UI: Â±ïÁ§∫ËØÑÂàÜÂç°Âπ∂ÁΩÆ‰∏∫ loading ÊñáÊ°à
                const scoreSection = document.getElementById('scoreSection');
                const scoreSummary = document.getElementById('scoreSummary');
                const scoreDetails = document.getElementById('scoreDetails');
                if(scoreSection) scoreSection.hidden = false;
                if(scoreSummary){ scoreSummary.textContent = 'Ê≠£Âú®ËØÑÂàÜ‚Ä¶'; scoreSummary.style.color = ''; }
                if(scoreDetails) scoreDetails.textContent = '';

                const targetSr = 16000; // Áªü‰∏ÄÂà∞ 16k ËÆ°ÁÆó
                let { pcm, sr } = await decodeToPCM(blob);
                if (!pcm || pcm.length === 0) {
                    // Ëß£Á†ÅÂ§±Ë¥•ÂÖúÂ∫ïÔºöÂ∞ùËØïÁõ¥Êé•Áî®ÂéüÂßã blob Êí≠ÊîæÂπ∂ÁªôÂá∫ÊèêÁ§∫ÔºåÂêåÊó∂ÈÅøÂÖçËØÑÂàÜÂÖ®‰∏∫ 0
                    if (scoreSummary) scoreSummary.textContent = 'Èü≥È¢ëËß£Á†ÅÂ§±Ë¥•Ôºå‰ΩøÁî®Á©∫ÁâπÂæÅËØÑÂàÜÔºàËØ∑ÈáçËØïÊàñÊõ¥Êç¢ÊµèËßàÂô®Ôºâ';
                    pcm = new Array(targetSr).fill(0); // 1ÁßíÈùôÈü≥ÔºåÈò≤Ê≠¢ÂêéÁª≠ÊµÅÁ®ãÂ¥©Ê∫É
                    sr = targetSr;
                }
                if (!sr || !isFinite(sr) || sr <= 0) sr = targetSr;
                const pcm16k = resampleLinear(pcm, sr, targetSr);
                const feats = computeFeatures(pcm16k, targetSr);

                const refWords = getRefWords();
                const { words } = computeDurationsFromTokens();
                const wordCount = words.length;

                // ËßÑÂàôÂåñÂª∫ËÆÆ
                const tips = [];
                if (feats.rmsMean < 0.12) tips.push('Èü≥ÈáèÁï•Â∞èÔºåÂèØÈù†ËøëÈ∫¶ÂÖãÈ£éÊàñÊèêÈ´òËØ¥ËØùÈü≥Èáè');
                if (feats.rmsMean > 0.35) tips.push('Èü≥ÈáèÂÅèÂ§ßÔºåÂèØËÉΩÂèëÁîüÂâäÊ≥¢ÔºåÂèØÈôç‰ΩéÈü≥Èáè');
                if (feats.f0PctValid < 0.3) tips.push('Âü∫È¢ë‰∏çÁ®≥ÂÆöÔºåÊ≥®ÊÑè‰øùÊåÅÂπ≥Á®≥ÁöÑÂèëÂ£∞');
                if (feats.gapsSec > Math.max(1.0, 0.5*wordCount)) tips.push('ÂÅúÈ°øËæÉÂ§öÔºåÂ∞ùËØïÊõ¥ËøûË¥ØÂú∞ËØ¥Âá∫Êï¥Âè•');

                // ËÆ°ÁÆóÂêØÂèëÂºèÈü≥Á¥†ËØÑÂàÜÔºà‰ª£ÁêÜ GOPÔºâ
                let advProxy = null;
                try {
                    const { perWordSec } = computeDurationsFromTokens();
                    const phones = wordsToPhones(refWords);
                    const timeline = buildPhonemeTimeline(refWords, perWordSec, phones);
                    const proxy = computeProxyGOP(pcm16k, targetSr, timeline);
                    advProxy = {
                        score: Math.round(proxy.avg*100),
                        weakPhonemes: proxy.scores.slice().sort((a,b)=>a.score-b.score).slice(0,3).map(x=>x.p),
                        phonemeCount: proxy.scores.length,
                        method: 'proxy',
                        segments: proxy.scores.map(x=>({ p: x.p, start: x.start, end: x.end, score: Math.round((x.score||0)*100) }))
                    };
                } catch {}

                // ÁúüÂÆû GOPÔºàCTCÔºâ
                let advReal = null;
                try { advReal = await tryComputeRealGOP(pcm16k, targetSr, refWords); } catch {}

                // ÁºìÂ≠ò‰æõÊ®°ÂºèÂàáÊç¢Â§çÁî®
                __lastScoring = { feats, wordCount, tips, advProxy, advReal, werInfo: null };
                __renderScoringFromCache();

                // ‚Äî‚Äî Á¶ªÁ∫ø ASRÔºöËØÜÂà´ + WER ÂØπÈΩê + È´ò‰∫ÆÔºàÂêéÂè∞ËøΩÂä†ÔºåÂºÇÊ≠•Ôºå‰∏çÈòªÂ°ûËØÑÂàÜÔºâ ‚Äî‚Äî
                const __runWerAsync = async () => {
                    try {
                        if (!__voskRec) {
                            if (scoreDetails) scoreDetails.textContent += `\nÊèêÁ§∫ÔºöÈ¶ñÊ¨°Âä†ËΩΩÁ¶ªÁ∫øËØÜÂà´Ê®°ÂûãÔºåÂèØËÉΩÈúÄË¶ÅÊï∞ÂçÅÁßíÔºåËØ∑ËÄêÂøÉÁ≠âÂæÖ‚Ä¶`;
                        }
                        const { words: hypWords } = await runVoskOnPCM(pcm16k);
                        if (__token !== window.__scoringToken) return; // Â∑≤ÊúâÊñ∞ËØÑÂàÜÔºå‰∏¢ÂºÉÊóßÁªìÊûú
                        const FILLERS = new Set(['uh','um','ah','er','erm','hmm','mm','uhh','umm']);
                        const hyp = Array.isArray(hypWords) ? hypWords.map(w=>normalizeWord(w.word)).filter(w=>w && !FILLERS.has(w)) : [];
                        const ref = getRefWords();
                        const werInfo = alignWER(ref, hyp);
                        if (__token !== window.__scoringToken) return; // ÂÜçÊ¨°Ê£ÄÊü•
                        clearAccuracyHighlights && clearAccuracyHighlights();
                        applyAlignmentToTokens && applyAlignmentToTokens(werInfo.aligned);
                        if (__lastScoring) { __lastScoring.werInfo = werInfo; }
                        __renderScoringFromCache();
                    } catch (e) { console.warn('WER ÂØπÈΩêÂ§±Ë¥•Ôºà‰∏çÂΩ±ÂìçÂü∫Á°ÄËØÑÂàÜÔºâÔºö', e); }
                };
                // ÊèêÂâçÈáäÊîæÂøôÁ¢åÁä∂ÊÄÅÔºåÂÖÅËÆ∏‰∏ã‰∏ÄÊ¨°ËØÑÂàÜ
                window.__scoringBusy = false;
                __runWerAsync();
            } catch(err){
                const scoreSummary = document.getElementById('scoreSummary');
                const scoreDetails = document.getElementById('scoreDetails');
                if(scoreSummary) scoreSummary.textContent = 'ËØÑÂàÜÂ§±Ë¥•';
                if(scoreDetails) scoreDetails.textContent = String(err?.message||err||'');
            } finally {
                // ÂÖúÂ∫ïÔºöÁ°Æ‰øù‰∏ç‰ºöÂõ†ÂºÇÂ∏∏ËÄåÈïøÊó∂Èó¥Âç†Áî® busy Áä∂ÊÄÅ
                window.__scoringBusy = false;
            }
        }
        // Âú®ÂºÄÂßãÂΩïÈü≥Êó∂Ê∏ÖÁ©∫ËØÑÂàÜÂå∫Ôºà‰øùÊåÅ UI Âπ≤ÂáÄÔºâ
        (function(){
            const __origStart = startRecording;
            startRecording = async function(){
                try{
                    const scoreSection = document.getElementById('scoreSection');
                    const scoreSummary = document.getElementById('scoreSummary');
                    const scoreDetails = document.getElementById('scoreDetails');
                    if (typeof clearAccuracyHighlights === 'function') {
                        try { clearAccuracyHighlights(); } catch {}
                    }
                    if(scoreSummary) scoreSummary.textContent = '';
                    if(scoreDetails) scoreDetails.textContent = '';
                    if(scoreSection) scoreSection.hidden = true;
                }catch{}
                return __origStart.apply(this, arguments);
            }
        })();

        // ===== ËØÑÂàÜÊ®°ÂºèÊ∏≤ÊüìËæÖÂä©‰∏éÁªëÂÆö =====
        function __renderScoringFromCache(){
            const scoreSummary = document.getElementById('scoreSummary');
            const scoreDetails = document.getElementById('scoreDetails');
            const chipsEl = document.getElementById('phonemeChips');
            const tlEl = document.getElementById('phonemeTimeline');
            const sw = document.getElementById('scoreModeSwitch');
            if (sw){
                const btns = Array.from(sw.querySelectorAll('.ms-btn'));
                btns.forEach(b=> b.classList.toggle('active', b.getAttribute('data-mode')===__scoreMode));
            }
            if (!__lastScoring){
                if (scoreSummary) { scoreSummary.textContent = 'ÊöÇÊó†ËØÑÂàÜ'; scoreSummary.style.color = ''; }
                if (scoreDetails) scoreDetails.textContent = '';
                if (chipsEl) chipsEl.style.display = 'none';
                if (tlEl) tlEl.style.display = 'none';
                return;
            }
            const { feats, wordCount, tips, advProxy, advReal, werInfo } = __lastScoring;

            // ÈÄâÂèñÂΩìÂâçÊ®°Âºè‰∏ãÁöÑÈü≥Á¥†ÂàÜÊï∞Êù•Ê∫ê
            let phBase = null;
            if (__scoreMode==='basic'){
                if (werInfo && werInfo.counts){
                    const ok = Number(werInfo.counts.ok||0);
                    const sub = Number(werInfo.counts.sub||0);
                    const subNear = Number((werInfo.counts.subNear)||0);
                    const ins = Number(werInfo.counts.ins||0);
                    const del = Number(werInfo.counts.del||0);
                    // ÂáÜÁ°ÆÂ∫¶‰ªÖÂü∫‰∫é‚ÄúÂ∑≤ËØªÁöÑËØç‚ÄùÔºà‰∏çÊääÂà†Èô§ËÆ°ÂÖ•ÂàÜÊØçÔºâÔºåÈÅøÂÖçËØªÂ∞ëÈáèËØçÊó∂Ë¢´Êú™ËØªËØçÊãâ‰Ωé
                    const denomSpoken = ok + sub + subNear; // ‰ªÖÁªüËÆ°Â∑≤ËØªÂØπÈΩê
                    if (denomSpoken > 0){
                        const ratioSpoken = (ok + 0.8*subNear + 0.5*sub) / denomSpoken; // 0~1
                        phBase = Math.round(clamp01(ratioSpoken)*100);
                    } else if (Number.isFinite(werInfo.werWeighted)){
                        // Ê≤°ÊúâÊúâÊïàÂ∑≤ËØªËÆ°Êï∞Êó∂ÔºåÂõûÈÄÄÂà∞Âä†ÊùÉWERÔºàÂåÖÂê´DELÔºâÔºåÂÜç‰∏çË°åÂÜçÂõûÈÄÄÂà∞GOP
                        phBase = Math.round(clamp01(1 - werInfo.werWeighted) * 100);
                    }
                }
                if (phBase==null){ phBase = (advReal?.score ?? advProxy?.score ?? null); }
            } else if (__scoreMode==='real'){
                phBase = advReal?.score ?? null;
            } else if (__scoreMode==='proxy'){
                phBase = advProxy?.score ?? null;
            }
            const weakBase = (__scoreMode==='real' ? (advReal?.weakPhonemes||[]) : (__scoreMode==='proxy' ? (advProxy?.weakPhonemes||[]) : []));

            // ËØçÈÄü‰º∞ËÆ°Ôºà‰ªÖÁî®‰∫é FAC ÂÆåÊï¥Â∫¶Ôºâ
            const estRate = (wordCount>0 && feats.totalSec>0) ? (wordCount/feats.totalSec) : null;
            // Ë¶ÜÁõñÁéáÔºàÂÆåÊï¥Â∫¶ÔºâÔºö‰ºòÂÖà‰ΩøÁî®ÂΩïÈü≥È´ò‰∫ÆÁöÑ LCSÔºåÂÖ∂Ê¨°Áî® WER ÁöÑÂ∑≤ËØªÊØî‰æã (ok+sub+subNear)/refLenÔºõÈÉΩ‰∏çÂèØÁî®Êó∂ÂõûÈÄÄËá≥Êó∂ÈïøËøë‰ºº
            let coverageLCS = null, coverageWER = null, coverageTime = null, coveragePct = null;
            try {
                const c = window.__asrCoverage;
                if (c && typeof c.pct === 'number' && isFinite(c.pct)) coverageLCS = Number(c.pct);
            } catch {}
            if (werInfo && werInfo.counts){
                const ok = Number(werInfo.counts.ok||0);
                const sub = Number(werInfo.counts.sub||0);
                const subNear = Number((werInfo.counts.subNear)||0);
                const del = Number(werInfo.counts.del||0);
                const refLen = ok + sub + subNear + del;
                if (refLen > 0) coverageWER = ((ok + sub + subNear) / refLen) * 100;
            }
            try {
                const { perWordSec } = computeDurationsFromTokens();
                const expectedSec = Array.isArray(perWordSec) ? perWordSec.reduce((s,x)=>s + (Number(x)||0), 0) : 0;
                const voiced = Number(feats && feats.voicedSec || 0);
                if (expectedSec > 0 && voiced > 0) {
                    const r = Math.min(1, voiced / expectedSec);
                    coverageTime = r * 100;
                }
            } catch {}
            coveragePct = (coverageLCS != null) ? coverageLCS : ((coverageWER != null) ? coverageWER : coverageTime);
            // Ë¶ÜÁõñÁéáÂÖúÂ∫ïÔºö
            // 1) basic Ê®°Âºè‰∏ã‰∏îÂÆåÂÖ®Êó† WER/CTC Êó∂ÔºåË¶ÜÁõñÁéáÂæàÈ´ò(>=95%) Áõ¥Êé•Áî®‰ΩúÂáÜÁ°ÆÂ∫¶ÔºåÈÅøÂÖçË¢´‰ª£ÁêÜ GOP Êãâ‰ΩéÔºõ
            // 2) Âü∫ÂáÜÂè•ÂæàÁü≠(<=3‰∏™ËØç)Êó∂ÔºåÊõ¥‰ø°‰ªªË¶ÜÁõñÁéáÔºöËã•Ë¶ÜÁõñÁéá>=85%ÔºåÂ∞Ü phBase Ëá≥Â∞ëÊèêÂçáÂà∞Ë¶ÜÁõñÁéáÂàÜ„ÄÇ
            if (__scoreMode==='basic'){
                const noWer = !werInfo;
                if ((phBase==null || (noWer && phBase < 80)) && typeof coveragePct === 'number' && isFinite(coveragePct)){
                    const covScore = Math.round(coveragePct);
                    if (covScore >= 95){
                        phBase = covScore;
                    } else if (wordCount && wordCount <= 3 && covScore >= 85){
                        phBase = Math.max(phBase ?? 0, covScore);
                    }
                }
            }
            let repeatsCount = 0; if (werInfo && werInfo.counts) repeatsCount = Number(werInfo.counts.ins||0);
            const facScore = computeFACFromSignals({
                totalSec: feats.totalSec,
                voicedSec: feats.voicedSec,
                gapsSec: feats.gapsSec,
                longPauseCount: feats.longPauseCount,
                rmsStd: feats.rmsStd,
                rmsMean: feats.rmsMean,
                f0PctValid: feats.f0PctValid,
                phScore: phBase,
                weakPhonemes: weakBase,
                rateWps: estRate,
                coveragePct: coveragePct,
                maxPauseSec: feats.maxPauseSec,
                repeatsCount: repeatsCount,
                maxVoicedSegSec: feats.maxVoicedSegSec,
            });

            // Ê∏≤ÊüìËØÑÂàÜÊ¶ÇËßàÔºàÊåâÈúÄÊîæÂ§ßÂ∞èÂàÜÂπ∂Â∞ÅÈ°∂ 100Ôºâ
            const fBase = Number(facScore.fluency || 0);
            const aBase = Number(facScore.accuracy || 0);
            const cBase = Number(facScore.completeness || 0);
            const fScaled = Math.min(100, Math.round(fBase * 1.5)); // ÊµÅÁïÖÂ∫¶ √ó1.5
            const aScaled = Math.min(100, Math.round(aBase * 2.2)); // ÂáÜÁ°ÆÂ∫¶ √ó2.2
            const cScaled = Math.min(100, Math.round(cBase)); // ÂÆåÊï¥Â∫¶Â∞ÅÈ°∂ 100
            const breakdown = `<div class="fac-breakdown">`
                + `<div class=\"fac-item\"><div class=\"fac-label\">ÊµÅÁïÖÂ∫¶</div><div class=\"fac-score\">${fScaled}</div><div class=\"fac-sub\">Fluency</div></div>`
                + `<div class=\"fac-item\"><div class=\"fac-label\">ÂáÜÁ°ÆÂ∫¶</div><div class=\"fac-score\">${aScaled}</div><div class=\"fac-sub\">Accuracy</div></div>`
                + `<div class=\"fac-item\"><div class=\"fac-label\">ÂÆåÊï¥Â∫¶</div><div class=\"fac-score\">${cScaled}</div><div class=\"fac-sub\">Completeness</div></div>`
                + `</div>`;
            const overallScaled = Math.round((fScaled + aScaled + cScaled) / 3);
            if (scoreSummary) scoreSummary.innerHTML = renderScoreSummary(overallScaled) + breakdown + `<div class=\"score-note\">ÈááÁî®Â∞èÂûãÁ¶ªÁ∫øÊ®°ÂûãÔºåËØÑÂàÜÁªìÊûú‰ªÖ‰ΩúÂèÇËÄÉ</div>`;

            // ËØ¶ÊÉÖ‰ø°ÊÅØÊåâÈúÄÊ±Ç‰∏çÂÜçÂ±ïÁ§∫
            const lines = [];
            if (werInfo){
                const cw = werInfo.counts || {};
                lines.push(`ÂØπÈΩêÔºöÊ≠£Á°Æ ${cw.ok}ÔºåËøë‰ººÊõøÊç¢ ${cw.subNear||0}ÔºåÊõøÊç¢ ${cw.sub}ÔºåÂà†Èô§ ${cw.del}ÔºåÊèíÂÖ• ${cw.ins}ÔºàÂáÜÁ°ÆÂ∫¶Âü∫‰∫éÂ∑≤ËØªÔºâ`);
                if (Number.isFinite(werInfo.werWeighted)){
                    lines.push(`Âä†ÊùÉWERÔºö${Math.round(werInfo.werWeighted*100)}%ÔºåÂØπÂ∫îÂáÜÁ°ÆÂ∫¶‚âà${Math.round((1-werInfo.werWeighted)*100)}%`);
                }
            }
            if (coveragePct != null){ lines.push(`Ë¶ÜÁõñÁéáÔºö${Math.round(coveragePct)}%`); }
            if (Array.isArray(tips) && tips.length){ lines.push(`Âª∫ËÆÆÔºö${tips.join('Ôºõ')}`); }
            if (scoreDetails) scoreDetails.textContent = lines.join('\n');

            // Ê∏≤ÊüìÂº±È°π chips ‰∏éÊó∂Èó¥ËΩ¥
            const cur = (__scoreMode==='real') ? advReal : (__scoreMode==='proxy' ? advProxy : null);
            if (!cur){
                if (chipsEl) { chipsEl.style.display='none'; chipsEl.innerHTML=''; }
                if (tlEl) { tlEl.style.display='none'; tlEl.innerHTML=''; }
                return;
            }
            // chips
            if (chipsEl){
                const weak = (cur.weakPhonemes||[]).slice(0,6);
                chipsEl.innerHTML = weak.map(p=>`<span class="chip" title="Âº±È°π">${p}</span>`).join('');
                chipsEl.style.display = weak.length ? '' : 'none';
            }
            // timeline
            if (tlEl){
                const segs = cur.phonemeAlignment || cur.segments || [];
                if (!Array.isArray(segs) || !segs.length){ tlEl.style.display='none'; tlEl.innerHTML=''; return; }
                const getEnd = s => (s.endSec!=null?s.endSec:(s.end!=null?s.end:0));
                const getStart = s => (s.startSec!=null?s.startSec:(s.start!=null?s.start:0));
                const getPh = s => (s.p!=null?s.p:(s.ph!=null?s.ph:''));
                let dur = 0.001; for (let i=0;i<segs.length;i++){ const e = getEnd(segs[i]); if (e > dur) dur = e; }
                function toPct(t){ return Math.max(0, Math.min(100, (t/dur)*100)); }
                tlEl.innerHTML = segs.map(s=>{
                    const st = toPct(getStart(s));
                    const ed = toPct(getEnd(s));
                    const w = Math.max(0.5, ed - st);
                    const sc = Math.round(Number(s.score)||0);
                     const cls = sc>=85? 'seg ok' : sc>=70? 'seg warn' : 'seg bad';
                     const label = getPh(s) || '';
                     return `<div class="${cls}" style="left:${st}%;width:${w}%" title="${label} ${sc}">${label}</div>`;
                }).join('');
                tlEl.style.display = '';
            }
            try { if (typeof scheduleBlueClear === 'function') scheduleBlueClear(5000, true); } catch {}
        }
        (function bindScoreMode(){
            const sw = document.getElementById('scoreModeSwitch');
            if (!sw || sw.__bound) return; sw.__bound = true;
            // ÂàùÂßãÂåñÊøÄÊ¥ªÊÄÅ
            Array.from(sw.querySelectorAll('.ms-btn')).forEach(b=> b.classList.toggle('active', b.getAttribute('data-mode')===__scoreMode));
            sw.addEventListener('click', (e)=>{
                const btn = e.target.closest('.ms-btn');
                if (!btn) return;
                const m = btn.getAttribute('data-mode');
                if (!m) return;
                __scoreMode = m;
                Array.from(sw.querySelectorAll('.ms-btn')).forEach(b=> b.classList.toggle('active', b===btn));
                if (__lastScoring){ __renderScoringFromCache(); return; }
                if (lastRecordedBlob && (typeof scoringEnabled === 'undefined' || scoringEnabled)) { try { computeAndRenderScore(lastRecordedBlob); } catch{} }
            }, { capture: true });
        })();
    </script>
</body>
</html>